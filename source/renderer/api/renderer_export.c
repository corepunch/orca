// Generated by codegen utility
#include <include/api.h>
#include <source/renderer/api/renderer.h>
#define DECL(SHORT, LONG, CLASS, NAME, FIELD, TYPE,...) { \
	.id=&(struct ID){.Name=#CLASS"."NAME,.Identifier=SHORT}, \
	.FullIdentifier=LONG, \
	.Offset=offsetof(struct CLASS, FIELD), \
	.DataSize=sizeof(((struct CLASS *)NULL)->FIELD), \
	.DataType=TYPE, ##__VA_ARGS__ }

void luaX_pushfontface(lua_State *L, lpcfontface_t fontface) {
	lua_pushlightuserdata(L, (lpfontface_t)fontface);
}
lpfontface_t luaX_checkfontface(lua_State *L, int idx) {
	return lua_touserdata(L, idx);
}
void luaX_pushtimeline(lua_State *L, lpctimeline_t timeline) {
	lua_pushlightuserdata(L, (lptimeline_t)timeline);
}
lptimeline_t luaX_checktimeline(lua_State *L, int idx) {
	return lua_touserdata(L, idx);
}
void luaX_pushshader(lua_State *L, lpcshader_t shader) {
	lua_pushlightuserdata(L, (lpshader_t)shader);
}
lpshader_t luaX_checkshader(lua_State *L, int idx) {
	return lua_touserdata(L, idx);
}
void luaX_pushmodel(lua_State *L, lpcmodel_t model) {
	lua_pushlightuserdata(L, (lpmodel_t)model);
}
lpmodel_t luaX_checkmodel(lua_State *L, int idx) {
	return lua_touserdata(L, idx);
}
void luaX_pushshape(lua_State *L, lpcshape_t shape) {
	lua_pushlightuserdata(L, (lpshape_t)shape);
}
lpshape_t luaX_checkshape(lua_State *L, int idx) {
	return lua_touserdata(L, idx);
}
lpwindow_t luaX_checkwindow(lua_State *L, int idx) {
	return luaL_checkudata(L, idx, "window");
}
int f_window___index(lua_State *L) {
	switch(fnv1a32(luaL_checkstring(L, 2))) {
	}
	return 0;
}
int luaopen_orca_window(lua_State *L) {
	luaL_newmetatable(L, "window");
	luaL_setfuncs(L, ((luaL_Reg[]) {
		{ "__index", f_window___index },
		{ NULL, NULL },
	}), 0);

	return 1;
}
static const char *_BlendMode[] = {"alphaautomatic","opaque","alpha","additive","premultipliedalpha","mixedalpha",NULL};
eBlendMode_t luaX_checkBlendMode(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _BlendMode);
}
void luaX_pushBlendMode(lua_State *L, eBlendMode_t value) {
	assert(value >= 0 && value < 6);
	lua_pushstring(L, _BlendMode[value]);
}
static const char *_CompareFunc[] = {"never","always","less","lessorequal","greater","greaterorequal","equal","notequal","disabled",NULL};
eCompareFunc_t luaX_checkCompareFunc(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _CompareFunc);
}
void luaX_pushCompareFunc(lua_State *L, eCompareFunc_t value) {
	assert(value >= 0 && value < 9);
	lua_pushstring(L, _CompareFunc[value]);
}
static const char *_TextureFilter[] = {"nearest","linear","trilinear",NULL};
eTextureFilter_t luaX_checkTextureFilter(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _TextureFilter);
}
void luaX_pushTextureFilter(lua_State *L, eTextureFilter_t value) {
	assert(value >= 0 && value < 3);
	lua_pushstring(L, _TextureFilter[value]);
}
static const char *_TextureWrap[] = {"clamp","repeat","base",NULL};
eTextureWrap_t luaX_checkTextureWrap(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _TextureWrap);
}
void luaX_pushTextureWrap(lua_State *L, eTextureWrap_t value) {
	assert(value >= 0 && value < 3);
	lua_pushstring(L, _TextureWrap[value]);
}
static const char *_TextureFormat[] = {"automatic","rgba8","rgb8","alpha8","depthcomponent","depthstencil",NULL};
eTextureFormat_t luaX_checkTextureFormat(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _TextureFormat);
}
void luaX_pushTextureFormat(lua_State *L, eTextureFormat_t value) {
	assert(value >= 0 && value < 6);
	lua_pushstring(L, _TextureFormat[value]);
}
static const char *_MipmapMode[] = {"base","nearest","linear","trilinear",NULL};
eMipmapMode_t luaX_checkMipmapMode(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _MipmapMode);
}
void luaX_pushMipmapMode(lua_State *L, eMipmapMode_t value) {
	assert(value >= 0 && value < 4);
	lua_pushstring(L, _MipmapMode[value]);
}
static const char *_AnisotropyType[] = {"none","x2","x4","x8","x16",NULL};
eAnisotropyType_t luaX_checkAnisotropyType(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _AnisotropyType);
}
void luaX_pushAnisotropyType(lua_State *L, eAnisotropyType_t value) {
	assert(value >= 0 && value < 5);
	lua_pushstring(L, _AnisotropyType[value]);
}
static struct PropertyDesc const TextureProperties[kTextureNumProperties] = {
	/* Texture.MinificationFilter */ DECL(0x47bdcfab, 0x7754ff10,
	Texture, "MinificationFilter", MinificationFilter, kDataTypeEnum, .TypeString="Nearest,Linear,Trilinear"),
	/* Texture.MagnificationFilter */ DECL(0xf5ff802c, 0xa67f8f51,
	Texture, "MagnificationFilter", MagnificationFilter, kDataTypeEnum, .TypeString="Nearest,Linear,Trilinear"),
	/* Texture.WrapMode */ DECL(0xc2114a32, 0x9e74e991,
	Texture, "WrapMode", WrapMode, kDataTypeEnum, .TypeString="Clamp,Repeat,Base"),
	/* Texture.Format */ DECL(0xffb0ff72, 0xed27f91d,
	Texture, "Format", Format, kDataTypeEnum, .TypeString="Automatic,Rgba8,Rgb8,Alpha8,DepthComponent,DepthStencil"),
	/* Texture.Scale */ DECL(0x28528e11, 0xb118380c,
	Texture, "Scale", Scale, kDataTypeInt),
	/* Texture.MipmapMode */ DECL(0xb3ad7612, 0x2abbf39d,
	Texture, "MipmapMode", MipmapMode, kDataTypeEnum, .TypeString="Base,Nearest,Linear,Trilinear"),
	/* Texture.AnisotropyType */ DECL(0x78736795, 0x71b18c0a,
	Texture, "AnisotropyType", AnisotropyType, kDataTypeEnum, .TypeString="None,X2,X4,X8,X16"),
	/* Texture.Width */ DECL(0x3b42dfbf, 0xeaf7b06a,
	Texture, "Width", Width, kDataTypeInt),
	/* Texture.Height */ DECL(0x1bd13562, 0xa4615985,
	Texture, "Height", Height, kDataTypeInt),
};
static struct Texture TextureDefaults = {0};
LRESULT TextureProc(lpObject_t object, void* cmp, uint32_t message, wParam_t wparm, lParam_t lparm) {
	switch (message) {
}
	return FALSE;
}
void luaX_pushTexture(lua_State *L, lpcTexture_t Texture) {
	luaX_pushObject(L, CMP_GetObject(Texture));
}
lpTexture_t luaX_checkTexture(lua_State *L, int idx) {
	return GetTexture(luaX_checkObject(L, idx));
}
ORCA_API struct ClassDesc _Texture = {
	.ClassName = "Texture",
	.DefaultName = "Texture",
	.ContentType = "Texture",
	.Xmlns = "http://schemas.corepunch.com/orca/2006/xml/presentation",
	.ParentClasses = {NULL},
	.ClassID = ID_Texture,
	.ClassSize = sizeof(struct Texture),
	.Properties = TextureProperties,
	.ObjProc = TextureProc,
	.Defaults = &TextureDefaults,
	.NumProperties = kTextureNumProperties,
};
static const char *_ImageFormat[] = {"png","jpeg","svg","astc","pvrtc",NULL};
eImageFormat_t luaX_checkImageFormat(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _ImageFormat);
}
void luaX_pushImageFormat(lua_State *L, eImageFormat_t value) {
	assert(value >= 0 && value < 5);
	lua_pushstring(L, _ImageFormat[value]);
}
static const char *_AstcFormat[] = {"unormblock4x4","unormblock5x4","unormblock5x5","unormblock6x5","unormblock6x6","unormblock8x5","unormblock8x6","unormblock8x8","unormblock10x5","unormblock10x6","unormblock10x8","unormblock10x10","unormblock12x10","unormblock12x12","srgbblock4x4","srgbblock5x4","srgbblock5x5","srgbblock6x5","srgbblock6x6","srgbblock8x5","srgbblock8x6","srgbblock8x8","srgbblock10x5","srgbblock10x6","srgbblock10x8","srgbblock10x10","srgbblock12x10","srgbblock12x12",NULL};
eAstcFormat_t luaX_checkAstcFormat(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _AstcFormat);
}
void luaX_pushAstcFormat(lua_State *L, eAstcFormat_t value) {
	assert(value >= 0 && value < 28);
	lua_pushstring(L, _AstcFormat[value]);
}
static const char *_AtcCompressionScheme[] = {"explicitalpha","interpolatedalpha","rgb",NULL};
eAtcCompressionScheme_t luaX_checkAtcCompressionScheme(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _AtcCompressionScheme);
}
void luaX_pushAtcCompressionScheme(lua_State *L, eAtcCompressionScheme_t value) {
	assert(value >= 0 && value < 3);
	lua_pushstring(L, _AtcCompressionScheme[value]);
}
static const char *_AstcCompressionSpeed[] = {"veryfast","fast","medium","thorough","exhaustive",NULL};
eAstcCompressionSpeed_t luaX_checkAstcCompressionSpeed(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _AstcCompressionSpeed);
}
void luaX_pushAstcCompressionSpeed(lua_State *L, eAstcCompressionSpeed_t value) {
	assert(value >= 0 && value < 5);
	lua_pushstring(L, _AstcCompressionSpeed[value]);
}
static const char *_RawColorByteFormat[] = {"rgba8","rgb8","bgra8","rgba16f","rgb10a2","r11g11b10f","rgba32f",NULL};
eRawColorByteFormat_t luaX_checkRawColorByteFormat(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _RawColorByteFormat);
}
void luaX_pushRawColorByteFormat(lua_State *L, eRawColorByteFormat_t value) {
	assert(value >= 0 && value < 7);
	lua_pushstring(L, _RawColorByteFormat[value]);
}
static const char *_FilePngCompressionLevel[] = {"none","fast","normal","maximum","projectdefault",NULL};
eFilePngCompressionLevel_t luaX_checkFilePngCompressionLevel(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _FilePngCompressionLevel);
}
void luaX_pushFilePngCompressionLevel(lua_State *L, eFilePngCompressionLevel_t value) {
	assert(value >= 0 && value < 5);
	lua_pushstring(L, _FilePngCompressionLevel[value]);
}
static const char *_SpansionCompressionScheme[] = {"none","standard","enhanced",NULL};
eSpansionCompressionScheme_t luaX_checkSpansionCompressionScheme(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _SpansionCompressionScheme);
}
void luaX_pushSpansionCompressionScheme(lua_State *L, eSpansionCompressionScheme_t value) {
	assert(value >= 0 && value < 3);
	lua_pushstring(L, _SpansionCompressionScheme[value]);
}
static const char *_ImageType[] = {"normal","mask",NULL};
eImageType_t luaX_checkImageType(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _ImageType);
}
void luaX_pushImageType(lua_State *L, eImageType_t value) {
	assert(value >= 0 && value < 2);
	lua_pushstring(L, _ImageType[value]);
}
LRESULT Image_Start(lpObject_t, lpImage_t, wParam_t, StartEventPtr);
static struct PropertyDesc const ImageProperties[kImageNumProperties] = {
	/* Image.Source */ DECL(0x61e2a3f8, 0x166867e9,
	Image, "Source", Source, kDataTypeFixed),
	/* Image.PremultiplyAlpha */ DECL(0xa3c8af46, 0x31148dcb,
	Image, "PremultiplyAlpha", PremultiplyAlpha, kDataTypeBool),
	/* Image.Type */ DECL(0xd155d06d, 0x99fe2d14,
	Image, "Type", Type, kDataTypeEnum, .TypeString="Normal,Mask"),
	/* Image.HasMipmaps */ DECL(0xdb9ccf58, 0x80a3a705,
	Image, "HasMipmaps", HasMipmaps, kDataTypeBool),
	/* Image.Size */ DECL(0xa6478e7c, 0x9a62a1d5,
	Image, "Size", Size, kDataTypeFixed),
	/* Image.BitDepth */ DECL(0x7588b4d5, 0xefc52200,
	Image, "BitDepth", BitDepth, kDataTypeInt),
	/* Image.FileHasTransparency */ DECL(0x94ab250b, 0xfc123168,
	Image, "FileHasTransparency", FileHasTransparency, kDataTypeBool),
	/* Image.FileHasICCProfile */ DECL(0xb5f815c3, 0xaaee61e0,
	Image, "FileHasICCProfile", FileHasICCProfile, kDataTypeBool),
	/* Image.TargetFormat */ DECL(0x86ff7dab, 0xd74be3d2,
	Image, "TargetFormat", TargetFormat, kDataTypeEnum, .TypeString="Png,Jpeg,Svg,Astc,Pvrtc"),
	/* Image.AtcCompressionScheme */ DECL(0x79fe08b6, 0x22a6ef8f,
	Image, "AtcCompressionScheme", AtcCompressionScheme, kDataTypeEnum, .TypeString="ExplicitAlpha,InterpolatedAlpha,Rgb"),
	/* Image.PvrtcBitDepth */ DECL(0x18e754ba, 0xa390fd11,
	Image, "PvrtcBitDepth", PvrtcBitDepth, kDataTypeInt),
	/* Image.PvrtcQuality */ DECL(0x022a53d7, 0xb2467a22,
	Image, "PvrtcQuality", PvrtcQuality, kDataTypeInt),
	/* Image.PvrtcCompressionScheme */ DECL(0x55e09913, 0xddf62696,
	Image, "PvrtcCompressionScheme", PvrtcCompressionScheme, kDataTypeInt),
	/* Image.AstcBlockSize */ DECL(0x8bceff48, 0x1cac5bd7,
	Image, "AstcBlockSize", AstcBlockSize, kDataTypeEnum, .TypeString="UnormBlock4x4,UnormBlock5x4,UnormBlock5x5,UnormBlock6x5,UnormBlock6x6,UnormBlock8x5,UnormBlock8x6,UnormBlock8x8,UnormBlock10x5,UnormBlock10x6,UnormBlock10x8,UnormBlock10x10,UnormBlock12x10,UnormBlock12x12,SrgbBlock4x4,SrgbBlock5x4,SrgbBlock5x5,SrgbBlock6x5,SrgbBlock6x6,SrgbBlock8x5,SrgbBlock8x6,SrgbBlock8x8,SrgbBlock10x5,SrgbBlock10x6,SrgbBlock10x8,SrgbBlock10x10,SrgbBlock12x10,SrgbBlock12x12"),
	/* Image.AstcCompressionSpeed */ DECL(0x52120f05, 0x6d6dc40c,
	Image, "AstcCompressionSpeed", AstcCompressionSpeed, kDataTypeEnum, .TypeString="VeryFast,Fast,Medium,Thorough,Exhaustive"),
	/* Image.AstcIsSRGB */ DECL(0x0ccdd5f0, 0x313c91b9,
	Image, "AstcIsSRGB", AstcIsSRGB, kDataTypeBool),
	/* Image.RawColorByteFormat */ DECL(0xfe76304d, 0x42cc3148,
	Image, "RawColorByteFormat", RawColorByteFormat, kDataTypeEnum, .TypeString="Rgba8,Rgb8,Bgra8,Rgba16f,Rgb10a2,R11g11b10f,Rgba32f"),
	/* Image.SpansionCompressionScheme */ DECL(0x66001361, 0x61c3662a,
	Image, "SpansionCompressionScheme", SpansionCompressionScheme, kDataTypeEnum, .TypeString="None,Standard,Enhanced"),
	/* Image.FilePngCompressionLevel */ DECL(0x28b08476, 0x4b9a9f8d,
	Image, "FilePngCompressionLevel", FilePngCompressionLevel, kDataTypeEnum, .TypeString="None,Fast,Normal,Maximum,ProjectDefault"),
	/* Image.Etc2Effort */ DECL(0xd96ef887, 0x57e2a766,
	Image, "Etc2Effort", Etc2Effort, kDataTypeInt),
	/* Image.FileExportSourceTexture */ DECL(0x84841aff, 0xaaaa5dcc,
	Image, "FileExportSourceTexture", FileExportSourceTexture, kDataTypeBool),
	/* Image.FileExportAlways */ DECL(0xc1e7dbf8, 0xf92536f5,
	Image, "FileExportAlways", FileExportAlways, kDataTypeBool),
	/* Image.FileExportEmptyWhenFileIsMissing */ DECL(0x1c849134, 0x68f7ba95,
	Image, "FileExportEmptyWhenFileIsMissing", FileExportEmptyWhenFileIsMissing, kDataTypeBool),
	/* Image.FileExportSourceImage */ DECL(0x85202b31, 0x5a4a8dc2,
	Image, "FileExportSourceImage", FileExportSourceImage, kDataTypeFixed),
};
static struct Image ImageDefaults = {0};
LRESULT ImageProc(lpObject_t object, void* cmp, uint32_t message, wParam_t wparm, lParam_t lparm) {
	switch (message) {
		case 0x0ae8097f: // Start
			return Image_Start(object, cmp, wparm, lparm);
}
	return FALSE;
}
void luaX_pushImage(lua_State *L, lpcImage_t Image) {
	luaX_pushObject(L, CMP_GetObject(Image));
}
lpImage_t luaX_checkImage(lua_State *L, int idx) {
	return GetImage(luaX_checkObject(L, idx));
}
extern struct ClassDesc _Texture;
ORCA_API struct ClassDesc _Image = {
	.ClassName = "Image",
	.DefaultName = "Image",
	.ContentType = "Texture",
	.Xmlns = "None",
	.ParentClasses = {&_Texture, NULL},
	.ClassID = ID_Image,
	.ClassSize = sizeof(struct Image),
	.Properties = ImageProperties,
	.ObjProc = ImageProc,
	.Defaults = &ImageDefaults,
	.NumProperties = kImageNumProperties,
};
static const char *_RenderTargetType[] = {"color","depth","stencil","depthstencil","normal","specular","emission",NULL};
eRenderTargetType_t luaX_checkRenderTargetType(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _RenderTargetType);
}
void luaX_pushRenderTargetType(lua_State *L, eRenderTargetType_t value) {
	assert(value >= 0 && value < 7);
	lua_pushstring(L, _RenderTargetType[value]);
}
static const char *_RenderTargetTextureAttachment[] = {"none","color0","color1","color2","color3","depth","stencil","depthstencil",NULL};
eRenderTargetTextureAttachment_t luaX_checkRenderTargetTextureAttachment(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _RenderTargetTextureAttachment);
}
void luaX_pushRenderTargetTextureAttachment(lua_State *L, eRenderTargetTextureAttachment_t value) {
	assert(value >= 0 && value < 8);
	lua_pushstring(L, _RenderTargetTextureAttachment[value]);
}
LRESULT RenderTargetTexture_Start(lpObject_t, lpRenderTargetTexture_t, wParam_t, StartEventPtr);
static struct PropertyDesc const RenderTargetTextureProperties[kRenderTargetTextureNumProperties] = {
	/* RenderTargetTexture.Width */ DECL(0x3b42dfbf, 0x2dca80b1,
	RenderTargetTexture, "Width", Width, kDataTypeInt),
	/* RenderTargetTexture.Height */ DECL(0x1bd13562, 0xf6e2f600,
	RenderTargetTexture, "Height", Height, kDataTypeInt),
	/* RenderTargetTexture.TargetType */ DECL(0x77ada720, 0xb4a182b2,
	RenderTargetTexture, "TargetType", TargetType, kDataTypeEnum, .TypeString="Color,Depth,Stencil,DepthStencil,Normal,Specular,Emission"),
	/* RenderTargetTexture.SupportSimpleRenderTarget */ DECL(0xdb3b9d57, 0xd37457e1,
	RenderTargetTexture, "SupportSimpleRenderTarget", SupportSimpleRenderTarget, kDataTypeBool),
	/* RenderTargetTexture.Attachment */ DECL(0x9048e288, 0x0744e91a,
	RenderTargetTexture, "Attachment", Attachment, kDataTypeEnum, .TypeString="None,Color0,Color1,Color2,Color3,Depth,Stencil,DepthStencil"),
	/* RenderTargetTexture.AllowDepthFallback */ DECL(0x337c9af1, 0x3e197723,
	RenderTargetTexture, "AllowDepthFallback", AllowDepthFallback, kDataTypeBool),
	/* RenderTargetTexture.SampleCount */ DECL(0x76f1691e, 0x03d063ec,
	RenderTargetTexture, "SampleCount", SampleCount, kDataTypeInt),
};
static struct RenderTargetTexture RenderTargetTextureDefaults = {0};
LRESULT RenderTargetTextureProc(lpObject_t object, void* cmp, uint32_t message, wParam_t wparm, lParam_t lparm) {
	switch (message) {
		case 0x0ae8097f: // Start
			return RenderTargetTexture_Start(object, cmp, wparm, lparm);
}
	return FALSE;
}
void luaX_pushRenderTargetTexture(lua_State *L, lpcRenderTargetTexture_t RenderTargetTexture) {
	luaX_pushObject(L, CMP_GetObject(RenderTargetTexture));
}
lpRenderTargetTexture_t luaX_checkRenderTargetTexture(lua_State *L, int idx) {
	return GetRenderTargetTexture(luaX_checkObject(L, idx));
}
extern struct ClassDesc _Texture;
ORCA_API struct ClassDesc _RenderTargetTexture = {
	.ClassName = "RenderTargetTexture",
	.DefaultName = "RenderTargetTexture",
	.ContentType = "Texture",
	.Xmlns = "None",
	.ParentClasses = {&_Texture, NULL},
	.ClassID = ID_RenderTargetTexture,
	.ClassSize = sizeof(struct RenderTargetTexture),
	.Properties = RenderTargetTextureProperties,
	.ObjProc = RenderTargetTextureProc,
	.Defaults = &RenderTargetTextureDefaults,
	.NumProperties = kRenderTargetTextureNumProperties,
};
LRESULT CubeMapTexture_Start(lpObject_t, lpCubeMapTexture_t, wParam_t, StartEventPtr);
static struct PropertyDesc const CubeMapTextureProperties[kCubeMapTextureNumProperties] = {
	/* CubeMapTexture.BackImage */ DECL(0x59f82b67, 0xd189d077,
	CubeMapTexture, "BackImage", BackImage, kDataTypeFixed),
	/* CubeMapTexture.FrontImage */ DECL(0xe5328805, 0xa6452b75,
	CubeMapTexture, "FrontImage", FrontImage, kDataTypeFixed),
	/* CubeMapTexture.LeftImage */ DECL(0xd2e8522d, 0xe2e29d5d,
	CubeMapTexture, "LeftImage", LeftImage, kDataTypeFixed),
	/* CubeMapTexture.RightImage */ DECL(0x7d77ff5a, 0xb9fcef0a,
	CubeMapTexture, "RightImage", RightImage, kDataTypeFixed),
	/* CubeMapTexture.BottomImage */ DECL(0xea5c127f, 0x92854acf,
	CubeMapTexture, "BottomImage", BottomImage, kDataTypeFixed),
	/* CubeMapTexture.TopImage */ DECL(0x5d1df0f9, 0x5899f7e9,
	CubeMapTexture, "TopImage", TopImage, kDataTypeFixed),
};
static struct CubeMapTexture CubeMapTextureDefaults = {0};
LRESULT CubeMapTextureProc(lpObject_t object, void* cmp, uint32_t message, wParam_t wparm, lParam_t lparm) {
	switch (message) {
		case 0x0ae8097f: // Start
			return CubeMapTexture_Start(object, cmp, wparm, lparm);
}
	return FALSE;
}
void luaX_pushCubeMapTexture(lua_State *L, lpcCubeMapTexture_t CubeMapTexture) {
	luaX_pushObject(L, CMP_GetObject(CubeMapTexture));
}
lpCubeMapTexture_t luaX_checkCubeMapTexture(lua_State *L, int idx) {
	return GetCubeMapTexture(luaX_checkObject(L, idx));
}
extern struct ClassDesc _Texture;
ORCA_API struct ClassDesc _CubeMapTexture = {
	.ClassName = "CubeMapTexture",
	.DefaultName = "CubeMapTexture",
	.ContentType = "Texture",
	.Xmlns = "None",
	.ParentClasses = {&_Texture, NULL},
	.ClassID = ID_CubeMapTexture,
	.ClassSize = sizeof(struct CubeMapTexture),
	.Properties = CubeMapTextureProperties,
	.ObjProc = CubeMapTextureProc,
	.Defaults = &CubeMapTextureDefaults,
	.NumProperties = kCubeMapTextureNumProperties,
};
LRESULT IOSurfaceTexture_Start(lpObject_t, lpIOSurfaceTexture_t, wParam_t, StartEventPtr);
static struct PropertyDesc const IOSurfaceTextureProperties[kIOSurfaceTextureNumProperties] = {
	/* IOSurfaceTexture.IOSurface */ DECL(0xb5fc4968, 0xc182dd0a,
	IOSurfaceTexture, "IOSurface", IOSurface, kDataTypeInt),
};
static struct IOSurfaceTexture IOSurfaceTextureDefaults = {0};
LRESULT IOSurfaceTextureProc(lpObject_t object, void* cmp, uint32_t message, wParam_t wparm, lParam_t lparm) {
	switch (message) {
		case 0x0ae8097f: // Start
			return IOSurfaceTexture_Start(object, cmp, wparm, lparm);
}
	return FALSE;
}
void luaX_pushIOSurfaceTexture(lua_State *L, lpcIOSurfaceTexture_t IOSurfaceTexture) {
	luaX_pushObject(L, CMP_GetObject(IOSurfaceTexture));
}
lpIOSurfaceTexture_t luaX_checkIOSurfaceTexture(lua_State *L, int idx) {
	return GetIOSurfaceTexture(luaX_checkObject(L, idx));
}
extern struct ClassDesc _Texture;
ORCA_API struct ClassDesc _IOSurfaceTexture = {
	.ClassName = "IOSurfaceTexture",
	.DefaultName = "IOSurfaceTexture",
	.ContentType = "Texture",
	.Xmlns = "None",
	.ParentClasses = {&_Texture, NULL},
	.ClassID = ID_IOSurfaceTexture,
	.ClassSize = sizeof(struct IOSurfaceTexture),
	.Properties = IOSurfaceTextureProperties,
	.ObjProc = IOSurfaceTextureProc,
	.Defaults = &IOSurfaceTextureDefaults,
	.NumProperties = kIOSurfaceTextureNumProperties,
};
static const char *_FloatPrecision[] = {"unset","low","medium","high",NULL};
eFloatPrecision_t luaX_checkFloatPrecision(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _FloatPrecision);
}
void luaX_pushFloatPrecision(lua_State *L, eFloatPrecision_t value) {
	assert(value >= 0 && value < 4);
	lua_pushstring(L, _FloatPrecision[value]);
}
static const char *_Shading[] = {"unlit","phong","standard",NULL};
eShading_t luaX_checkShading(lua_State *L, int idx) {
	return luaL_checkoption(L, idx, NULL, _Shading);
}
void luaX_pushShading(lua_State *L, eShading_t value) {
	assert(value >= 0 && value < 3);
	lua_pushstring(L, _Shading[value]);
}
static struct PropertyDesc const VertexShaderProperties[kVertexShaderNumProperties] = {
	/* VertexShader.Version */ DECL(0x5dcdd537, 0x82819cc8,
	VertexShader, "Version", Version, kDataTypeInt),
	/* VertexShader.FloatPrecision */ DECL(0x1ecae757, 0xfce1e8ba,
	VertexShader, "FloatPrecision", FloatPrecision, kDataTypeEnum, .TypeString="Unset,Low,Medium,High"),
	/* VertexShader.Shading */ DECL(0x2cbcb34d, 0x22b3da6e,
	VertexShader, "Shading", Shading, kDataTypeEnum, .TypeString="Unlit,Phong,Standard"),
};
static struct VertexShader VertexShaderDefaults = {0};
LRESULT VertexShaderProc(lpObject_t object, void* cmp, uint32_t message, wParam_t wparm, lParam_t lparm) {
	switch (message) {
}
	return FALSE;
}
void luaX_pushVertexShader(lua_State *L, lpcVertexShader_t VertexShader) {
	luaX_pushObject(L, CMP_GetObject(VertexShader));
}
lpVertexShader_t luaX_checkVertexShader(lua_State *L, int idx) {
	return GetVertexShader(luaX_checkObject(L, idx));
}
ORCA_API struct ClassDesc _VertexShader = {
	.ClassName = "VertexShader",
	.DefaultName = "VertexShader",
	.ContentType = "VertexShader",
	.Xmlns = "http://schemas.corepunch.com/orca/2006/xml/presentation",
	.ParentClasses = {NULL},
	.ClassID = ID_VertexShader,
	.ClassSize = sizeof(struct VertexShader),
	.Properties = VertexShaderProperties,
	.ObjProc = VertexShaderProc,
	.Defaults = &VertexShaderDefaults,
	.NumProperties = kVertexShaderNumProperties,
};
static struct PropertyDesc const FragmentShaderProperties[kFragmentShaderNumProperties] = {
	/* FragmentShader.Version */ DECL(0x5dcdd537, 0xd376e806,
	FragmentShader, "Version", Version, kDataTypeInt),
	/* FragmentShader.FloatPrecision */ DECL(0x1ecae757, 0x56221774,
	FragmentShader, "FloatPrecision", FloatPrecision, kDataTypeEnum, .TypeString="Unset,Low,Medium,High"),
	/* FragmentShader.Out */ DECL(0x0da660ff, 0x7d35d16e,
	FragmentShader, "Out", Out, kDataTypeFixed),
};
static struct FragmentShader FragmentShaderDefaults = {0};
LRESULT FragmentShaderProc(lpObject_t object, void* cmp, uint32_t message, wParam_t wparm, lParam_t lparm) {
	switch (message) {
}
	return FALSE;
}
void luaX_pushFragmentShader(lua_State *L, lpcFragmentShader_t FragmentShader) {
	luaX_pushObject(L, CMP_GetObject(FragmentShader));
}
lpFragmentShader_t luaX_checkFragmentShader(lua_State *L, int idx) {
	return GetFragmentShader(luaX_checkObject(L, idx));
}
ORCA_API struct ClassDesc _FragmentShader = {
	.ClassName = "FragmentShader",
	.DefaultName = "FragmentShader",
	.ContentType = "FragmentShader",
	.Xmlns = "http://schemas.corepunch.com/orca/2006/xml/presentation",
	.ParentClasses = {NULL},
	.ClassID = ID_FragmentShader,
	.ClassSize = sizeof(struct FragmentShader),
	.Properties = FragmentShaderProperties,
	.ObjProc = FragmentShaderProc,
	.Defaults = &FragmentShaderDefaults,
	.NumProperties = kFragmentShaderNumProperties,
};
LRESULT Shader_Start(lpObject_t, lpShader_t, wParam_t, StartEventPtr);
LRESULT Shader_Destroy(lpObject_t, lpShader_t, wParam_t, DestroyEventPtr);
static struct PropertyDesc const ShaderProperties[kShaderNumProperties] = {
	/* Shader.BlendMode */ DECL(0x0038792b, 0xf81788a6,
	Shader, "BlendMode", BlendMode, kDataTypeEnum, .TypeString="AlphaAutomatic,Opaque,Alpha,Additive,PremultipliedAlpha,MixedAlpha"),
	/* Shader.DepthTestFunction */ DECL(0xb7e582be, 0xca9708bf,
	Shader, "DepthTestFunction", DepthTestFunction, kDataTypeEnum, .TypeString="Never,Always,Less,LessOrEqual,Greater,GreaterOrEqual,Equal,NotEqual,Disabled"),
	/* Shader.DepthWriteEnabled */ DECL(0x8ec3072e, 0xec8378fb,
	Shader, "DepthWriteEnabled", DepthWriteEnabled, kDataTypeBool),
};
static struct Shader ShaderDefaults = {
	.BlendMode = -1,
};
LRESULT ShaderProc(lpObject_t object, void* cmp, uint32_t message, wParam_t wparm, lParam_t lparm) {
	switch (message) {
		case 0x0ae8097f: // Start
			return Shader_Start(object, cmp, wparm, lparm);
		case 0x4d76a4e5: // Destroy
			return Shader_Destroy(object, cmp, wparm, lparm);
}
	return FALSE;
}
void luaX_pushShader(lua_State *L, lpcShader_t Shader) {
	luaX_pushObject(L, CMP_GetObject(Shader));
}
lpShader_t luaX_checkShader(lua_State *L, int idx) {
	return GetShader(luaX_checkObject(L, idx));
}
ORCA_API struct ClassDesc _Shader = {
	.ClassName = "Shader",
	.DefaultName = "Shader",
	.ContentType = "Shader",
	.Xmlns = "http://schemas.corepunch.com/orca/2006/xml/presentation",
	.ParentClasses = {NULL},
	.ClassID = ID_Shader,
	.ClassSize = sizeof(struct Shader),
	.Properties = ShaderProperties,
	.ObjProc = ShaderProc,
	.Defaults = &ShaderDefaults,
	.NumProperties = kShaderNumProperties,
};
static struct PropertyDesc const MaterialProperties[kMaterialNumProperties] = {
	/* Material.Shader */ DECL(0x7deb3888, 0xb1f27f23,
	Material, "Shader", Shader, kDataTypeObject, .TypeString="Shader"),
	/* Material.GlobalAmbient */ DECL(0x63792322, 0x4c3b3e9b,
	Material, "GlobalAmbient", GlobalAmbient, kDataTypeColor),
	/* Material.Ambient */ DECL(0x33f2678b, 0x2722ee06,
	Material, "Ambient", Ambient, kDataTypeColor),
	/* Material.Diffuse */ DECL(0x84d12add, 0x5d1fb2d8,
	Material, "Diffuse", Diffuse, kDataTypeColor),
	/* Material.Emissive */ DECL(0x555cbaee, 0x94dc948d,
	Material, "Emissive", Emissive, kDataTypeColor),
	/* Material.SpecularColor */ DECL(0xd5e66b37, 0x88c8734e,
	Material, "SpecularColor", SpecularColor, kDataTypeColor),
	/* Material.SpecularExponent */ DECL(0x841db767, 0xdf2c70ac,
	Material, "SpecularExponent", SpecularExponent, kDataTypeFloat),
	/* Material.Texture */ DECL(0x994c5594, 0x0789ca7d,
	Material, "Texture", Texture, kDataTypeObject, .TypeString="Texture"),
	/* Material.Texture2 */ DECL(0xf92ad452, 0x2ce97a5d,
	Material, "Texture2", Texture2, kDataTypeObject, .TypeString="Texture"),
	/* Material.TextureOffset */ DECL(0xe83ca8af, 0x3275cc12,
	Material, "TextureOffset", TextureOffset, kDataTypeVector2D),
	/* Material.TextureTiling */ DECL(0x861dbc5b, 0xa7a60572,
	Material, "TextureTiling", TextureTiling, kDataTypeVector2D),
	/* Material.BlendIntensity */ DECL(0x5df90df9, 0x7f786186,
	Material, "BlendIntensity", BlendIntensity, kDataTypeFloat),
	/* Material.BlendMode */ DECL(0x0038792b, 0x4a26ef0e,
	Material, "BlendMode", BlendMode, kDataTypeEnum, .TypeString="AlphaAutomatic,Opaque,Alpha,Additive,PremultipliedAlpha,MixedAlpha"),
	/* Material.U_color */ DECL(0xe31e6650, 0x9379cad9,
	Material, "U_color", u_color, kDataTypeColor),
	/* Material.U_texture */ DECL(0x668311ac, 0x36ecb8f9,
	Material, "U_texture", u_texture, kDataTypeObject, .TypeString="Texture"),
};
static struct Material MaterialDefaults = {
	.BlendMode = kBlendModeAlphaAutomatic,
};
LRESULT MaterialProc(lpObject_t object, void* cmp, uint32_t message, wParam_t wparm, lParam_t lparm) {
	switch (message) {
}
	return FALSE;
}
void luaX_pushMaterial(lua_State *L, lpcMaterial_t Material) {
	luaX_pushObject(L, CMP_GetObject(Material));
}
lpMaterial_t luaX_checkMaterial(lua_State *L, int idx) {
	return GetMaterial(luaX_checkObject(L, idx));
}
ORCA_API struct ClassDesc _Material = {
	.ClassName = "Material",
	.DefaultName = "Material",
	.ContentType = "Material",
	.Xmlns = "http://schemas.corepunch.com/orca/2006/xml/presentation",
	.ParentClasses = {NULL},
	.ClassID = ID_Material,
	.ClassSize = sizeof(struct Material),
	.Properties = MaterialProperties,
	.ObjProc = MaterialProc,
	.Defaults = &MaterialDefaults,
	.NumProperties = kMaterialNumProperties,
};
LRESULT Mesh_Start(lpObject_t, lpMesh_t, wParam_t, StartEventPtr);
LRESULT Mesh_Destroy(lpObject_t, lpMesh_t, wParam_t, DestroyEventPtr);
static struct PropertyDesc const MeshProperties[kMeshNumProperties] = {
	/* Mesh.Source */ DECL(0x61e2a3f8, 0xc235363b,
	Mesh, "Source", Source, kDataTypeFixed),
	/* Mesh.Material */ DECL(0xcbd54f80, 0xfc82924b,
	Mesh, "Material", Material, kDataTypeObject, .TypeString="Material"),
	/* Mesh.MeshMorphTargets */ DECL(0x553fd778, 0x6984d367,
	Mesh, "MeshMorphTargets", MeshMorphTargets, kDataTypeFixed),
};
static struct Mesh MeshDefaults = {0};
LRESULT MeshProc(lpObject_t object, void* cmp, uint32_t message, wParam_t wparm, lParam_t lparm) {
	switch (message) {
		case 0x0ae8097f: // Start
			return Mesh_Start(object, cmp, wparm, lparm);
		case 0x4d76a4e5: // Destroy
			return Mesh_Destroy(object, cmp, wparm, lparm);
}
	return FALSE;
}
void luaX_pushMesh(lua_State *L, lpcMesh_t Mesh) {
	luaX_pushObject(L, CMP_GetObject(Mesh));
}
lpMesh_t luaX_checkMesh(lua_State *L, int idx) {
	return GetMesh(luaX_checkObject(L, idx));
}
ORCA_API struct ClassDesc _Mesh = {
	.ClassName = "Mesh",
	.DefaultName = "Mesh",
	.ContentType = "Mesh",
	.Xmlns = "http://schemas.corepunch.com/orca/2006/xml/presentation",
	.ParentClasses = {NULL},
	.ClassID = ID_Mesh,
	.ClassSize = sizeof(struct Mesh),
	.Properties = MeshProperties,
	.ObjProc = MeshProc,
	.Defaults = &MeshDefaults,
	.NumProperties = kMeshNumProperties,
};
LRESULT FontFamily_Start(lpObject_t, lpFontFamily_t, wParam_t, StartEventPtr);
LRESULT FontFamily_Destroy(lpObject_t, lpFontFamily_t, wParam_t, DestroyEventPtr);
static struct PropertyDesc const FontFamilyProperties[kFontFamilyNumProperties] = {
	/* FontFamily.Regular */ DECL(0xe750f2b7, 0xb39a4ebe,
	FontFamily, "Regular", Regular, kDataTypeFixed),
	/* FontFamily.Bold */ DECL(0x45768d96, 0xb22930ed,
	FontFamily, "Bold", Bold, kDataTypeFixed),
	/* FontFamily.Italic */ DECL(0x8db0c08d, 0x1eb759ae,
	FontFamily, "Italic", Italic, kDataTypeFixed),
	/* FontFamily.BoldItalic */ DECL(0x6e1d4e1a, 0xb7a86f05,
	FontFamily, "BoldItalic", BoldItalic, kDataTypeFixed),
};
static struct FontFamily FontFamilyDefaults = {0};
LRESULT FontFamilyProc(lpObject_t object, void* cmp, uint32_t message, wParam_t wparm, lParam_t lparm) {
	switch (message) {
		case 0x0ae8097f: // Start
			return FontFamily_Start(object, cmp, wparm, lparm);
		case 0x4d76a4e5: // Destroy
			return FontFamily_Destroy(object, cmp, wparm, lparm);
}
	return FALSE;
}
void luaX_pushFontFamily(lua_State *L, lpcFontFamily_t FontFamily) {
	luaX_pushObject(L, CMP_GetObject(FontFamily));
}
lpFontFamily_t luaX_checkFontFamily(lua_State *L, int idx) {
	return GetFontFamily(luaX_checkObject(L, idx));
}
ORCA_API struct ClassDesc _FontFamily = {
	.ClassName = "FontFamily",
	.DefaultName = "FontFamily",
	.ContentType = "FontFamily",
	.Xmlns = "None",
	.ParentClasses = {NULL},
	.ClassID = ID_FontFamily,
	.ClassSize = sizeof(struct FontFamily),
	.Properties = FontFamilyProperties,
	.ObjProc = FontFamilyProc,
	.Defaults = &FontFamilyDefaults,
	.NumProperties = kFontFamilyNumProperties,
};
static struct PropertyDesc const TrajectoryProperties[kTrajectoryNumProperties] = {
};
static struct Trajectory TrajectoryDefaults = {};
LRESULT TrajectoryProc(lpObject_t object, void* cmp, uint32_t message, wParam_t wparm, lParam_t lparm) {
	switch (message) {
}
	return FALSE;
}
void luaX_pushTrajectory(lua_State *L, lpcTrajectory_t Trajectory) {
	luaX_pushObject(L, CMP_GetObject(Trajectory));
}
lpTrajectory_t luaX_checkTrajectory(lua_State *L, int idx) {
	return GetTrajectory(luaX_checkObject(L, idx));
}
ORCA_API struct ClassDesc _Trajectory = {
	.ClassName = "Trajectory",
	.DefaultName = "Trajectory",
	.ContentType = "Trajectory",
	.Xmlns = "None",
	.ParentClasses = {NULL},
	.ClassID = ID_Trajectory,
	.ClassSize = sizeof(struct Trajectory),
	.Properties = TrajectoryProperties,
	.ObjProc = TrajectoryProc,
	.Defaults = &TrajectoryDefaults,
	.NumProperties = kTrajectoryNumProperties,
};
static struct PropertyDesc const TimelineProperties[kTimelineNumProperties] = {
};
static struct Timeline TimelineDefaults = {};
LRESULT TimelineProc(lpObject_t object, void* cmp, uint32_t message, wParam_t wparm, lParam_t lparm) {
	switch (message) {
}
	return FALSE;
}
void luaX_pushTimeline(lua_State *L, lpcTimeline_t Timeline) {
	luaX_pushObject(L, CMP_GetObject(Timeline));
}
lpTimeline_t luaX_checkTimeline(lua_State *L, int idx) {
	return GetTimeline(luaX_checkObject(L, idx));
}
ORCA_API struct ClassDesc _Timeline = {
	.ClassName = "Timeline",
	.DefaultName = "Timeline",
	.ContentType = "Timeline",
	.Xmlns = "None",
	.ParentClasses = {NULL},
	.ClassID = ID_Timeline,
	.ClassSize = sizeof(struct Timeline),
	.Properties = TimelineProperties,
	.ObjProc = TimelineProc,
	.Defaults = &TimelineDefaults,
	.NumProperties = kTimelineNumProperties,
};
static int f_renderer_createShader(lua_State *L) {
	const char* vertex = luaL_checkstring(L, 1);
	const char* fragment = luaL_checkstring(L, 2);
	lpShader_t output = renderer_CreateShader(L, vertex, fragment);
	luaX_pushShader(L, output);
	return 1;
}
static int f_renderer_getSize(lua_State *L) {
	return renderer_GetSize(L);
}
static int f_renderer_drawImage(lua_State *L) {
	renderer_DrawImage(L);
	return 0;
}
ORCA_API int luaopen_orca_renderer(lua_State *L) {
	luaL_newlib(L, ((luaL_Reg[]) {
		{ "createShader", f_renderer_createShader },
		{ "getSize", f_renderer_getSize },
		{ "drawImage", f_renderer_drawImage },
		{ NULL, NULL }
	}));
	// window
	luaopen_orca_window(L);
	lua_setfield(L, -2, "Window");
	// Texture
	lua_pushclass(L, &_Texture);
	lua_setfield(L, -2, "Texture");
	// Image
	lua_pushclass(L, &_Image);
	lua_setfield(L, -2, "Image");
	// RenderTargetTexture
	lua_pushclass(L, &_RenderTargetTexture);
	lua_setfield(L, -2, "RenderTargetTexture");
	// CubeMapTexture
	lua_pushclass(L, &_CubeMapTexture);
	lua_setfield(L, -2, "CubeMapTexture");
	// IOSurfaceTexture
	lua_pushclass(L, &_IOSurfaceTexture);
	lua_setfield(L, -2, "IOSurfaceTexture");
	// VertexShader
	lua_pushclass(L, &_VertexShader);
	lua_setfield(L, -2, "VertexShader");
	// FragmentShader
	lua_pushclass(L, &_FragmentShader);
	lua_setfield(L, -2, "FragmentShader");
	// Shader
	lua_pushclass(L, &_Shader);
	lua_setfield(L, -2, "Shader");
	// Material
	lua_pushclass(L, &_Material);
	lua_setfield(L, -2, "Material");
	// Mesh
	lua_pushclass(L, &_Mesh);
	lua_setfield(L, -2, "Mesh");
	// FontFamily
	lua_pushclass(L, &_FontFamily);
	lua_setfield(L, -2, "FontFamily");
	// Trajectory
	lua_pushclass(L, &_Trajectory);
	lua_setfield(L, -2, "Trajectory");
	// Timeline
	lua_pushclass(L, &_Timeline);
	lua_setfield(L, -2, "Timeline");
	return 1;
}
