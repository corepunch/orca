// Generated by codegen utility
#ifndef __RENDERER_H__
#define __RENDERER_H__

#include <include/orca.h>

#include <source/renderer/api/renderer_properties.h>

typedef struct window window_t, *lpwindow_t;
typedef struct window const cwindow_t, *lpcwindow_t;
/// @brief Push window onto Lua stack.
ORCA_API void
luaX_pushwindow(lua_State *L, lpcwindow_t window);
/// @brief Check window form Lua stack at index.
ORCA_API lpwindow_t
luaX_checkwindow(lua_State *L, int idx);

typedef struct Texture Texture_t, *lpTexture_t;
typedef struct Texture const cTexture_t, *lpcTexture_t;
/// @brief Push Texture onto Lua stack.
ORCA_API void
luaX_pushTexture(lua_State *L, lpcTexture_t Texture);
/// @brief Check Texture form Lua stack at index.
ORCA_API lpTexture_t
luaX_checkTexture(lua_State *L, int idx);

typedef struct Image Image_t, *lpImage_t;
typedef struct Image const cImage_t, *lpcImage_t;
/// @brief Push Image onto Lua stack.
ORCA_API void
luaX_pushImage(lua_State *L, lpcImage_t Image);
/// @brief Check Image form Lua stack at index.
ORCA_API lpImage_t
luaX_checkImage(lua_State *L, int idx);

typedef struct RenderTargetTexture RenderTargetTexture_t, *lpRenderTargetTexture_t;
typedef struct RenderTargetTexture const cRenderTargetTexture_t, *lpcRenderTargetTexture_t;
/// @brief Push RenderTargetTexture onto Lua stack.
ORCA_API void
luaX_pushRenderTargetTexture(lua_State *L, lpcRenderTargetTexture_t RenderTargetTexture);
/// @brief Check RenderTargetTexture form Lua stack at index.
ORCA_API lpRenderTargetTexture_t
luaX_checkRenderTargetTexture(lua_State *L, int idx);

typedef struct CubeMapTexture CubeMapTexture_t, *lpCubeMapTexture_t;
typedef struct CubeMapTexture const cCubeMapTexture_t, *lpcCubeMapTexture_t;
/// @brief Push CubeMapTexture onto Lua stack.
ORCA_API void
luaX_pushCubeMapTexture(lua_State *L, lpcCubeMapTexture_t CubeMapTexture);
/// @brief Check CubeMapTexture form Lua stack at index.
ORCA_API lpCubeMapTexture_t
luaX_checkCubeMapTexture(lua_State *L, int idx);

typedef struct IOSurfaceTexture IOSurfaceTexture_t, *lpIOSurfaceTexture_t;
typedef struct IOSurfaceTexture const cIOSurfaceTexture_t, *lpcIOSurfaceTexture_t;
/// @brief Push IOSurfaceTexture onto Lua stack.
ORCA_API void
luaX_pushIOSurfaceTexture(lua_State *L, lpcIOSurfaceTexture_t IOSurfaceTexture);
/// @brief Check IOSurfaceTexture form Lua stack at index.
ORCA_API lpIOSurfaceTexture_t
luaX_checkIOSurfaceTexture(lua_State *L, int idx);

typedef struct VertexShader VertexShader_t, *lpVertexShader_t;
typedef struct VertexShader const cVertexShader_t, *lpcVertexShader_t;
/// @brief Push VertexShader onto Lua stack.
ORCA_API void
luaX_pushVertexShader(lua_State *L, lpcVertexShader_t VertexShader);
/// @brief Check VertexShader form Lua stack at index.
ORCA_API lpVertexShader_t
luaX_checkVertexShader(lua_State *L, int idx);

typedef struct FragmentShader FragmentShader_t, *lpFragmentShader_t;
typedef struct FragmentShader const cFragmentShader_t, *lpcFragmentShader_t;
/// @brief Push FragmentShader onto Lua stack.
ORCA_API void
luaX_pushFragmentShader(lua_State *L, lpcFragmentShader_t FragmentShader);
/// @brief Check FragmentShader form Lua stack at index.
ORCA_API lpFragmentShader_t
luaX_checkFragmentShader(lua_State *L, int idx);

typedef struct Shader Shader_t, *lpShader_t;
typedef struct Shader const cShader_t, *lpcShader_t;
/// @brief Push Shader onto Lua stack.
ORCA_API void
luaX_pushShader(lua_State *L, lpcShader_t Shader);
/// @brief Check Shader form Lua stack at index.
ORCA_API lpShader_t
luaX_checkShader(lua_State *L, int idx);

typedef struct Material Material_t, *lpMaterial_t;
typedef struct Material const cMaterial_t, *lpcMaterial_t;
/// @brief Push Material onto Lua stack.
ORCA_API void
luaX_pushMaterial(lua_State *L, lpcMaterial_t Material);
/// @brief Check Material form Lua stack at index.
ORCA_API lpMaterial_t
luaX_checkMaterial(lua_State *L, int idx);

typedef struct Mesh Mesh_t, *lpMesh_t;
typedef struct Mesh const cMesh_t, *lpcMesh_t;
/// @brief Push Mesh onto Lua stack.
ORCA_API void
luaX_pushMesh(lua_State *L, lpcMesh_t Mesh);
/// @brief Check Mesh form Lua stack at index.
ORCA_API lpMesh_t
luaX_checkMesh(lua_State *L, int idx);

typedef struct FontFamily FontFamily_t, *lpFontFamily_t;
typedef struct FontFamily const cFontFamily_t, *lpcFontFamily_t;
/// @brief Push FontFamily onto Lua stack.
ORCA_API void
luaX_pushFontFamily(lua_State *L, lpcFontFamily_t FontFamily);
/// @brief Check FontFamily form Lua stack at index.
ORCA_API lpFontFamily_t
luaX_checkFontFamily(lua_State *L, int idx);

typedef struct Trajectory Trajectory_t, *lpTrajectory_t;
typedef struct Trajectory const cTrajectory_t, *lpcTrajectory_t;
/// @brief Push Trajectory onto Lua stack.
ORCA_API void
luaX_pushTrajectory(lua_State *L, lpcTrajectory_t Trajectory);
/// @brief Check Trajectory form Lua stack at index.
ORCA_API lpTrajectory_t
luaX_checkTrajectory(lua_State *L, int idx);

typedef struct Timeline Timeline_t, *lpTimeline_t;
typedef struct Timeline const cTimeline_t, *lpcTimeline_t;
/// @brief Push Timeline onto Lua stack.
ORCA_API void
luaX_pushTimeline(lua_State *L, lpcTimeline_t Timeline);
/// @brief Check Timeline form Lua stack at index.
ORCA_API lpTimeline_t
luaX_checkTimeline(lua_State *L, int idx);

typedef struct font font_t, *lpfont_t;
typedef struct font const cfont_t, *lpcfont_t;
/// @brief Push font onto Lua stack.
ORCA_API void
luaX_pushfont(lua_State *L, lpcfont_t font);
/// @brief Check font form Lua stack at index.
ORCA_API lpfont_t
luaX_checkfont(lua_State *L, int idx);

typedef struct timeline timeline_t, *lptimeline_t;
typedef struct timeline const ctimeline_t, *lpctimeline_t;
/// @brief Push timeline onto Lua stack.
ORCA_API void
luaX_pushtimeline(lua_State *L, lpctimeline_t timeline);
/// @brief Check timeline form Lua stack at index.
ORCA_API lptimeline_t
luaX_checktimeline(lua_State *L, int idx);

typedef struct shader shader_t, *lpshader_t;
typedef struct shader const cshader_t, *lpcshader_t;
/// @brief Push shader onto Lua stack.
ORCA_API void
luaX_pushshader(lua_State *L, lpcshader_t shader);
/// @brief Check shader form Lua stack at index.
ORCA_API lpshader_t
luaX_checkshader(lua_State *L, int idx);

typedef struct model model_t, *lpmodel_t;
typedef struct model const cmodel_t, *lpcmodel_t;
/// @brief Push model onto Lua stack.
ORCA_API void
luaX_pushmodel(lua_State *L, lpcmodel_t model);
/// @brief Check model form Lua stack at index.
ORCA_API lpmodel_t
luaX_checkmodel(lua_State *L, int idx);

typedef struct shape shape_t, *lpshape_t;
typedef struct shape const cshape_t, *lpcshape_t;
/// @brief Push shape onto Lua stack.
ORCA_API void
luaX_pushshape(lua_State *L, lpcshape_t shape);
/// @brief Check shape form Lua stack at index.
ORCA_API lpshape_t
luaX_checkshape(lua_State *L, int idx);

typedef enum BlendMode {
	kBlendModeAlphaAutomatic, /// Automatic alpha mode selection
	kBlendModeOpaque, /// Fully opaque rendering, no transparency
	kBlendModeAlpha, /// Standard alpha blending
	kBlendModeAdditive, /// Additive color blending
	kBlendModePremultipliedAlpha, /// Alpha-premultiplied blending
	kBlendModeMixedAlpha, /// Mixed alpha composition
} eBlendMode_t;

typedef enum CompareFunc {
	kCompareFuncNever, /// Test never passes - all fragments are rejected
	kCompareFuncAlways, /// Test always passes - all fragments are accepted
	kCompareFuncLess, /// Test passes if new value is less than stored value
	kCompareFuncLessOrEqual, /// Test passes if new value is less than or equal to stored value
	kCompareFuncGreater, /// Test passes if new value is greater than stored value
	kCompareFuncGreaterOrEqual, /// Test passes if new value is greater than or equal to stored value
	kCompareFuncEqual, /// Test passes if new value equals stored value
	kCompareFuncNotEqual, /// Test passes if new value does not equal stored value
	kCompareFuncDisabled, /// Testing is disabled - equivalent to Always but may have performance benefits
} eCompareFunc_t;

typedef enum TextureFilter {
	kTextureFilterNearest, /// Uses nearest-neighbor sampling for sharp, pixelated appearance.
	kTextureFilterLinear, /// Uses bilinear interpolation for smooth texture sampling.
	kTextureFilterTrilinear, /// Uses trilinear interpolation with mipmap blending for high-quality filtered textures.
} eTextureFilter_t;

typedef enum TextureWrap {
	kTextureWrapClamp, /// Clamps texture coordinates to [0, 1] range, repeating edge pixels beyond boundaries.
	kTextureWrapRepeat, /// Repeats the texture pattern when coordinates exceed [0, 1] range.
	kTextureWrapBase, /// Uses base texture addressing mode (platform-specific default behavior).
} eTextureWrap_t;

typedef enum TextureFormat {
	kTextureFormatAutomatic, /// Uses default format from project settings, typically Rgba8 for standard color textures.
	kTextureFormatRgba8, /// Four-channel 8-bit format with red, green, blue, and alpha components (32 bits per pixel).
	kTextureFormatRgb8, /// Three-channel 8-bit format with red, green, and blue components only (24 bits per pixel).
	kTextureFormatAlpha8, /// Single-channel 8-bit format containing only alpha (transparency) values.
	kTextureFormatDepthComponent, /// Single-channel depth format for depth buffer rendering and shadow mapping.
	kTextureFormatDepthStencil, /// Combined depth and stencil format for advanced rendering techniques requiring both depth testing and stencil operations.
} eTextureFormat_t;

typedef enum MipmapMode {
	kMipmapModeBase, /// Only the base (highest-resolution) mip level is used. Fastest, but can cause aliasing when textures are minified.
	kMipmapModeNearest, /// Selects the nearest mip level based on the distance, without blending between levels. Produces sharper but less smooth transitions.
	kMipmapModeLinear, /// Interpolates between two nearest mip levels for smoother transitions. Common default for high-quality rendering.
	kMipmapModeTrilinear, /// Performs linear filtering across both texel and mip levels, providing the smoothest possible texture transitions (slightly slower).
} eMipmapMode_t;

typedef enum AnisotropyType {
	kAnisotropyTypeNone, /// Disables anisotropic filtering. Texture detail will degrade at oblique viewing angles.
	kAnisotropyTypeX2, /// Applies 2x anisotropic filtering, modestly improving texture clarity at shallow angles.
	kAnisotropyTypeX4, /// Applies 4x anisotropic filtering, balancing performance and quality.
	kAnisotropyTypeX8, /// Applies 8x anisotropic filtering for high-quality rendering with moderate cost.
	kAnisotropyTypeX16, /// Applies 16x anisotropic filtering for the sharpest textures at glancing angles, at higher GPU cost.
} eAnisotropyType_t;

typedef struct Texture Texture, *TexturePtr;
typedef struct Texture const *TextureCPtr;
/// @brief Base class for managing texture resources and their sampling parameters for rendering.
struct Texture {
	eTextureFilter_t MinificationFilter; /// Filtering method used when texture is rendered smaller than its original size.
	eTextureFilter_t MagnificationFilter; /// Filtering method used when texture is rendered larger than its original size.
	eTextureWrap_t WrapMode; /// Defines how texture coordinates outside [0, 1] range are handled.
	eTextureFormat_t Format; /// Specifies the internal pixel format and channel layout used for texture storage in GPU memory.
	int32_t Scale; /// Scale factor for high-DPI display support. Indicates the pixel density multiplier (e.g., 1 for standard displays, 2 for Retina/2x displays, 3 for 3x displays). The texture is loaded at higher resolution and scaled down for rendering on high-DPI screens.
	eMipmapMode_t MipmapMode; /// Controls how mipmaps are sampled when rendering the texture. Higher modes like `Linear` and `Trilinear` yield smoother transitions at the cost of performance.
	eAnisotropyType_t AnisotropyType; /// Defines the anisotropic filtering level applied to the texture. Improves clarity at shallow view angles; higher values offer better quality with greater GPU cost.
	int32_t Width; /// Actual width of the texture in pixels.
	int32_t Height; /// Actual height of the texture in pixels.
	uint32_t IOSurface; /// macOS-specific handle to an IOSurface object for zero-copy texture sharing between processes and frameworks.
	uint32_t texnum; /// OpenGL texture object identifier assigned by the GPU driver.
	uint32_t framebuffer; /// OpenGL framebuffer object identifier for render-to-texture operations.
	uint32_t depthbuffer; /// OpenGL depth buffer (renderbuffer) object identifier for depth testing when rendering to this texture.
	bool_t loaded; /// Used for on-demand texture loading.
};

typedef enum ImageFormat {
	kImageFormatPng, /// Portable Network Graphics — lossless compression, supports alpha channel, widely used for UI textures and screenshots
	kImageFormatJpeg, /// Joint Photographic Experts Group — lossy compression, smaller file sizes, no full alpha support, suitable for photos
	kImageFormatSvg, /// Scalable Vector Graphics — vector format, resolution-independent, ideal for icons, logos, and UI elements that need to scale without loss
	kImageFormatAstc, /// Adaptive Scalable Texture Compression — block-based GPU texture compression format supporting lossy and near-lossless modes, with alpha channel support. Optimized for real-time rendering and mobile/embedded GPUs.
	kImageFormatPvrtc, /// PowerVR Texture Compression — hardware texture compression format optimized for PowerVR GPUs (common in iOS devices). Provides efficient storage with optional alpha support, suitable for mobile real-time graphics.
} eImageFormat_t;

typedef enum AstcFormat {
	kAstcFormatUnormBlock4x4, /// 4×4 block, unsigned normalized RGBA — highest quality, 8 bits per channel
	kAstcFormatUnormBlock5x4, /// 5×4 block, unsigned normalized RGBA — slightly higher compression, good quality
	kAstcFormatUnormBlock5x5, /// 5×5 block, unsigned normalized RGBA — balance between quality and size
	kAstcFormatUnormBlock6x5, /// 6×5 block, unsigned normalized RGBA — higher compression, lower quality than smaller blocks
	kAstcFormatUnormBlock6x6, /// 6×6 block, unsigned normalized RGBA — good compression for large textures
	kAstcFormatUnormBlock8x5, /// 8×5 block, unsigned normalized RGBA — moderate quality, smaller size
	kAstcFormatUnormBlock8x6, /// 8×6 block, unsigned normalized RGBA — further reduced size
	kAstcFormatUnormBlock8x8, /// 8×8 block, unsigned normalized RGBA — high compression, lower visual quality
	kAstcFormatUnormBlock10x5, /// 10×5 block, unsigned normalized RGBA — increased compression ratio
	kAstcFormatUnormBlock10x6, /// 10×6 block, unsigned normalized RGBA — high compression
	kAstcFormatUnormBlock10x8, /// 10×8 block, unsigned normalized RGBA — smaller file size
	kAstcFormatUnormBlock10x10, /// 10×10 block, unsigned normalized RGBA — large blocks, lower quality
	kAstcFormatUnormBlock12x10, /// 12×10 block, unsigned normalized RGBA — high compression, lower quality
	kAstcFormatUnormBlock12x12, /// 12×12 block, unsigned normalized RGBA — maximum compression, lowest quality
	kAstcFormatSrgbBlock4x4, /// 4×4 block, sRGB color space — highest quality for gamma-corrected textures
	kAstcFormatSrgbBlock5x4, /// 5×4 block, sRGB color space — slightly higher compression
	kAstcFormatSrgbBlock5x5, /// 5×5 block, sRGB color space — balanced quality and size
	kAstcFormatSrgbBlock6x5, /// 6×5 block, sRGB color space — higher compression
	kAstcFormatSrgbBlock6x6, /// 6×6 block, sRGB color space — moderate quality
	kAstcFormatSrgbBlock8x5, /// 8×5 block, sRGB color space — good compression for large textures
	kAstcFormatSrgbBlock8x6, /// 8×6 block, sRGB color space — higher compression
	kAstcFormatSrgbBlock8x8, /// 8×8 block, sRGB color space — large blocks, reduced quality
	kAstcFormatSrgbBlock10x5, /// 10×5 block, sRGB color space — high compression
	kAstcFormatSrgbBlock10x6, /// 10×6 block, sRGB color space — smaller size, lower quality
	kAstcFormatSrgbBlock10x8, /// 10×8 block, sRGB color space — more compression, lower quality
	kAstcFormatSrgbBlock10x10, /// 10×10 block, sRGB color space — very high compression, low quality
	kAstcFormatSrgbBlock12x10, /// 12×10 block, sRGB color space — extreme compression, low visual fidelity
	kAstcFormatSrgbBlock12x12, /// 12×12 block, sRGB color space — maximum compression, lowest quality
} eAstcFormat_t;

typedef enum AtcCompressionScheme {
	kAtcCompressionSchemeExplicitAlpha, /// RGB + separate alpha block (8 bits) — better alpha quality, slightly larger size
	kAtcCompressionSchemeInterpolatedAlpha, /// RGB + interpolated alpha values — smaller size, lower alpha precision
	kAtcCompressionSchemeRgb, /// RGB only, no alpha channel — smallest size and fastest decoding
} eAtcCompressionScheme_t;

typedef enum AstcCompressionSpeed {
	kAstcCompressionSpeedVeryFast, /// lowest quality, fastest encode — for real-time or previews
	kAstcCompressionSpeedFast, /// slightly better quality, still quite fast
	kAstcCompressionSpeedMedium, /// good balance between speed and quality (default in many tools)
	kAstcCompressionSpeedThorough, /// slower, higher quality (offline textures)
	kAstcCompressionSpeedExhaustive, /// best possible quality, extremely slow — for final offline baking
} eAstcCompressionSpeed_t;

typedef enum RawColorByteFormat {
	kRawColorByteFormatRgba8, /// 8 bits per channel, unsigned normalized RGBA — the standard format for general use
	kRawColorByteFormatRgb8, /// 8 bits per channel, unsigned normalized RGB — no alpha channel
	kRawColorByteFormatBgra8, /// 8 bits per channel, unsigned normalized BGRA — used on some GPU backends and APIs like DirectX
	kRawColorByteFormatRgba16f, /// 16-bit floating point per channel RGBA — for HDR or high-precision color
	kRawColorByteFormatRgb10a2, /// 10 bits for RGB, 2 bits for alpha — compact HDR-like format
	kRawColorByteFormatR11g11b10f, /// 11/11/10-bit floating point RGB, no alpha — optimized for HDR rendering
	kRawColorByteFormatRgba32f, /// 32-bit floating point per channel RGBA — maximum precision, used in offline or scientific rendering
} eRawColorByteFormat_t;

typedef enum FilePngCompressionLevel {
	kFilePngCompressionLevelNone, /// no compression — largest files, fastest save
	kFilePngCompressionLevelFast, /// light compression — minimal size reduction, quick encode
	kFilePngCompressionLevelNormal, /// balanced compression — default level in most tools
	kFilePngCompressionLevelMaximum, /// highest compression — smallest files, slower encode
	kFilePngCompressionLevelProjectDefault, /// use compression level defined by project settings
} eFilePngCompressionLevel_t;

typedef enum SpansionCompressionScheme {
	kSpansionCompressionSchemeNone, /// No compression applied to the data — used when maximum speed is required or when compression is handled elsewhere in the system
	kSpansionCompressionSchemeStandard, /// Standard compression applied — balances between compression ratio and speed
	kSpansionCompressionSchemeEnhanced, /// Enhanced compression applied — achieves higher compression ratios at the cost of increased processing time
} eSpansionCompressionScheme_t;

typedef enum ImageType {
	kImageTypeNormal,
	kImageTypeMask,
} eImageType_t;

typedef struct Image Image, *ImagePtr;
typedef struct Image const *ImageCPtr;
/// @brief Represents a single, pre-loaded texture image for use in rendering operations.
struct Image {
	fixedString_t Source; /// Path to the texture image file to be loaded.
	bool_t PremultiplyAlpha; /// When `true`, multiplies RGB channels by alpha during loading for correct alpha blending.
	eImageType_t Type; /// When set to `Mask`, treats the texture as an alpha mask, ignoring RGB components and using only the alpha channel for masking operations.
	bool_t HasMipmaps; /// When `true`, automatically generates mipmap levels for improved texture quality at varying distances and reduced aliasing artifacts.
	fixedString_t Size; /// Texture dimensions in the format "Width x Height", e.g., "256 x 256".
	int32_t BitDepth; /// Number of bits per pixel, including all channels.
	bool_t FileHasTransparency; /// Indicates whether the source file contains any transparent pixels.
	bool_t FileHasICCProfile; /// Indicates whether the source file includes an embedded ICC color profile.
	eImageFormat_t TargetFormat; /// The format to use when exporting or processing the texture (e.g., PNG, JPEG, SVG).
	eAtcCompressionScheme_t AtcCompressionScheme; /// Compression scheme to use for ATC textures.
	int32_t PvrtcBitDepth; /// Bit depth for PVRTC-compressed textures.
	int32_t PvrtcQuality; /// Compression quality setting for PVRTC textures.
	int32_t PvrtcCompressionScheme; /// Compression scheme used for PVRTC textures.
	eAstcFormat_t AstcBlockSize; /// ASTC block size to use when compressing the texture.
	eAstcCompressionSpeed_t AstcCompressionSpeed; /// Speed/quality preset for ASTC compression.
	bool_t AstcIsSRGB; /// Indicates whether ASTC texture uses sRGB color space.
	eRawColorByteFormat_t RawColorByteFormat; /// Format used for raw uncompressed color data.
	eSpansionCompressionScheme_t SpansionCompressionScheme; /// Compression scheme for Spansion flash memory, if applicable.
	eFilePngCompressionLevel_t FilePngCompressionLevel; /// Compression level used when saving PNG files.
	int32_t Etc2Effort; /// Effort/quality parameter for ETC2 compression.
	bool_t FileExportSourceTexture; /// When `true`, exports the original source texture file alongside processed versions.
	bool_t FileExportAlways; /// When `true`, ensures the texture is exported regardless of other conditions.
	bool_t FileExportEmptyWhenFileIsMissing; /// When `true`, exports an empty placeholder if the source file is missing.
	fixedString_t FileExportSourceImage;
};

typedef enum RenderTargetType {
	kRenderTargetTypeColor, /// Standard color attachment used for rendering the final image or intermediate color buffers
	kRenderTargetTypeDepth, /// Depth buffer attachment — stores depth information used for depth testing during rendering
	kRenderTargetTypeStencil, /// Stencil buffer attachment — stores per-pixel stencil values for masking and complex rendering effects
	kRenderTargetTypeDepthStencil, /// Combined depth and stencil attachment — used when both depth and stencil data are required in a single texture
	kRenderTargetTypeNormal, /// Optional attachment storing per-pixel normals for deferred rendering or post-processing
	kRenderTargetTypeSpecular, /// Optional attachment for storing specular intensity or color in deferred shading pipelines
	kRenderTargetTypeEmission, /// Optional attachment storing emissive light information for glow or lighting accumulation passes
} eRenderTargetType_t;

typedef enum RenderTargetTextureAttachment {
	kRenderTargetTextureAttachmentNone, /// No attachment — the texture is not bound to any framebuffer slot
	kRenderTargetTextureAttachmentColor0, /// First color attachment (default target for most rendering)
	kRenderTargetTextureAttachmentColor1, /// Second color attachment — used when multiple render targets (MRT) are active
	kRenderTargetTextureAttachmentColor2, /// Third color attachment
	kRenderTargetTextureAttachmentColor3, /// Fourth color attachment
	kRenderTargetTextureAttachmentDepth, /// Depth attachment — used for depth buffering
	kRenderTargetTextureAttachmentStencil, /// Stencil attachment — used for stencil operations
	kRenderTargetTextureAttachmentDepthStencil, /// Combined depth-stencil attachment
} eRenderTargetTextureAttachment_t;

typedef struct RenderTargetTexture RenderTargetTexture, *RenderTargetTexturePtr;
typedef struct RenderTargetTexture const *RenderTargetTextureCPtr;
/// @brief Texture configured as a render target for off-screen rendering and post-processing effects.
struct RenderTargetTexture {
	int32_t Width; /// The desired width in pixels for the render target texture, determining the horizontal resolution of rendered content.
	int32_t Height; /// The desired height in pixels for the render target texture, determining the vertical resolution of rendered content.
	eRenderTargetType_t TargetType; /// Specifies which kind of render target this texture represents — for example, a color, depth, or stencil attachment.
	bool_t SupportSimpleRenderTarget; /// Enables use of a simplified render target setup — typically a single color buffer without depth or stencil attachments, used for lightweight or offscreen rendering tasks.
	eRenderTargetTextureAttachment_t Attachment; /// Defines the framebuffer slot or channel this texture is attached to.
	bool_t AllowDepthFallback; /// Allows using a depth-only buffer as a fallback when a full depth-stencil attachment is unavailable, ensuring rendering can proceed with reduced functionality.
	int32_t SampleCount; /// Specifies the number of multisample samples used when rendering to this texture, controlling the level of anti-aliasing applied.
};

typedef struct CubeMapTexture CubeMapTexture, *CubeMapTexturePtr;
typedef struct CubeMapTexture const *CubeMapTextureCPtr;
/// @brief Cubemap texture assembled from six individual images, one for each face of a cube, used for environment mapping, reflections, and sky rendering.
struct CubeMapTexture {
	fixedString_t BackImage; /// Path to the image file for the back face (negative Z-axis) of the cubemap.
	fixedString_t FrontImage; /// Path to the image file for the front face (positive Z-axis) of the cubemap.
	fixedString_t LeftImage; /// Path to the image file for the left face (negative X-axis) of the cubemap.
	fixedString_t RightImage; /// Path to the image file for the right face (positive X-axis) of the cubemap.
	fixedString_t BottomImage; /// Path to the image file for the bottom face (negative Y-axis) of the cubemap.
	fixedString_t TopImage; /// Path to the image file for the top face (positive Y-axis) of the cubemap.
};

typedef struct IOSurfaceTexture IOSurfaceTexture, *IOSurfaceTexturePtr;
typedef struct IOSurfaceTexture const *IOSurfaceTextureCPtr;
/// @brief Texture created from a shared macOS IOSurface for zero-copy GPU data sharing.
struct IOSurfaceTexture {
	int32_t IOSurface; /// The IOSurface identifier used to look up and bind the shared surface as a texture.
};

typedef enum FloatPrecision {
	kFloatPrecisionUnset, /// No precision specified, may cause issues.
	kFloatPrecisionLow, /// Lowest precision, typically 8-16 bits. Suitable for color values and non-critical calculations.
	kFloatPrecisionMedium, /// Medium precision, typically 16-24 bits. Ideal for texture coordinates and general-purpose calculations.
	kFloatPrecisionHigh, /// Highest precision, typically 32 bits. Required for vertex positions, matrices, and critical transformations.
} eFloatPrecision_t;

typedef enum Shading {
	kShadingUnlit, /// No lighting calculations applied. Renders surfaces with their base color and texture without any light interaction. Suitable for UI elements, emissive materials, or pre-baked lighting.
	kShadingPhong, /// Classic Phong lighting model with ambient, diffuse, and specular components. Provides good performance with convincing highlights and shading for general-purpose 3D rendering.
	kShadingStandard, /// Physically-based rendering (PBR) model. Provides realistic material appearance based on physical light interaction principles, supporting metallic and roughness workflows.
} eShading_t;

typedef struct VertexShader VertexShader, *VertexShaderPtr;
typedef struct VertexShader const *VertexShaderCPtr;
/// @brief Vertex processing stage of the shader pipeline
struct VertexShader {
	int32_t Version; /// GLSL shader language version number (e.g., 150 for GLSL 1.50, 330 for GLSL 3.30)
	eFloatPrecision_t FloatPrecision; /// Default floating-point precision for vertex shader calculations
	eShading_t Shading; /// The lighting/shading model to use for vertex processing. Determines which lighting calculations are performed and how surface appearance is computed.
};

typedef struct FragmentShader FragmentShader, *FragmentShaderPtr;
typedef struct FragmentShader const *FragmentShaderCPtr;
/// @brief Fragment (pixel) processing stage of the shader pipeline
struct FragmentShader {
	int32_t Version; /// GLSL shader language version number (e.g., 150 for GLSL 1.50, 330 for GLSL 3.30)
	eFloatPrecision_t FloatPrecision; /// Default floating-point precision for fragment shader calculations
	fixedString_t Out; /// Name of the output variable for fragment color (e.g., "FragColor", "gl_FragColor")
};

typedef struct Shader Shader, *ShaderPtr;
typedef struct Shader const *ShaderCPtr;
/// @brief Complete shader program definition combining vertex and fragment stages
struct Shader {
	eBlendMode_t BlendMode; /// The default blending mode for the shader, controlling how rendered output combines with the existing framebuffer content.
	eCompareFunc_t DepthTestFunction; /// The default depth comparison function used for depth testing, determining which fragments are visible based on their depth values.
	bool_t DepthWriteEnabled; /// Whether depth buffer writing is enabled by default. When true, rendered fragments update the depth buffer; when false, depth values are not written.
	lpshader_t shader; /// Compiled shader for runtime use
};

typedef struct Material Material, *MaterialPtr;
typedef struct Material const *MaterialCPtr;
/// @brief Shader-based rendering material for advanced visual effects
struct Material {
	lpShader_t Shader; /// Shader program for custom rendering 
	color_t GlobalAmbient; /// Defines the global illumination color affecting all surfaces equally. Used to simulate indirect light in a scene.
	color_t Ambient; ///  Base color of the material under ambient lighting conditions, representing its response to non-directional light.
	color_t Diffuse; ///  Main reflective color of the material when illuminated by direct light sources.
	color_t Emissive; ///  Color emitted by the material itself, giving the appearance of self-illumination regardless of scene lighting.
	color_t SpecularColor; ///  Tint and intensity of the material’s reflective highlights when exposed to light sources.
	float SpecularExponent; ///  Controls the sharpness of specular highlights; higher values result in a glossier surface appearance.
	Texture_t Texture; /// Primary texture applied to the material surface
	Texture_t Texture2; /// Secondary texture applied to the material surface
	vec2_t TextureOffset; /// UV offset for the base texture mapping
	vec2_t TextureTiling; /// UV tiling (repetition) for the base texture mapping
	float BlendIntensity; /// Adjusts the opacity or blending strength of the material
	eBlendMode_t BlendMode; /// Blending mode for material rendering 
	color_t u_color; /// Uniform color parameter for shader 
	lpTexture_t u_texture; /// Uniform texture parameter for shader 
};

typedef struct Mesh Mesh, *MeshPtr;
typedef struct Mesh const *MeshCPtr;
/// @brief Renderable 3D geometry component with material and model data
struct Mesh {
	fixedString_t Source; /// Path or identifier to the mesh geometry file or resource. Specifies where to load the 3D model data from.
	lpMaterial_t Material; /// Reference to the material that defines the mesh's visual appearance. Controls shaders, textures, colors, and rendering properties applied to the geometry.
	fixedString_t MeshMorphTargets; /// Name of the morph targets in the mesh
	lpmodel_t model; /// Internal pointer to the loaded model data structure containing the mesh geometry.
};

typedef struct FontFamily FontFamily, *FontFamilyPtr;
typedef struct FontFamily const *FontFamilyCPtr;
/// @brief TrueType font resource for text rendering
struct FontFamily {
	fixedString_t Regular; /// Path or identifier to the TrueType font file (.ttf). Specifies the location of the font resource to load (e.g., file path, asset ID, or resource name).
	lpfont_t font; /// Internal pointer to the loaded font data.
};

typedef struct Trajectory Trajectory, *TrajectoryPtr;
typedef struct Trajectory const *TrajectoryCPtr;
struct Trajectory {
};

typedef struct Timeline Timeline, *TimelinePtr;
typedef struct Timeline const *TimelineCPtr;
struct Timeline {
};

/// @brief Creates a shader program from source code.
ORCA_API lpShader_t
renderer_CreateShader(lua_State *L, const char* vertex, const char* fragment);

/// @brief Retrieves the size of the current window.
ORCA_API int32_t
renderer_GetSize(lua_State *L);

/// @brief Draws the current image to the active render target.
ORCA_API void
renderer_DrawImage(lua_State *L);

#endif
