// Generated by codegen utility
#ifndef __SCENEKIT_H__
#define __SCENEKIT_H__

#include <include/orca.h>

#include <source/SceneKit/SceneKit_properties.h>

typedef struct Node3D Node3D_t, *lpNode3D_t;
typedef struct Node3D const cNode3D_t, *lpcNode3D_t;
/// @brief Push Node3D onto Lua stack.
ORCA_API void
luaX_pushNode3D(lua_State *L, lpcNode3D_t Node3D);
/// @brief Check Node3D form Lua stack at index.
ORCA_API lpNode3D_t
luaX_checkNode3D(lua_State *L, int idx);

typedef struct Scene Scene_t, *lpScene_t;
typedef struct Scene const cScene_t, *lpcScene_t;
/// @brief Push Scene onto Lua stack.
ORCA_API void
luaX_pushScene(lua_State *L, lpcScene_t Scene);
/// @brief Check Scene form Lua stack at index.
ORCA_API lpScene_t
luaX_checkScene(lua_State *L, int idx);

typedef struct Model3D Model3D_t, *lpModel3D_t;
typedef struct Model3D const cModel3D_t, *lpcModel3D_t;
/// @brief Push Model3D onto Lua stack.
ORCA_API void
luaX_pushModel3D(lua_State *L, lpcModel3D_t Model3D);
/// @brief Check Model3D form Lua stack at index.
ORCA_API lpModel3D_t
luaX_checkModel3D(lua_State *L, int idx);

typedef struct PlaneMeshNode PlaneMeshNode_t, *lpPlaneMeshNode_t;
typedef struct PlaneMeshNode const cPlaneMeshNode_t, *lpcPlaneMeshNode_t;
/// @brief Push PlaneMeshNode onto Lua stack.
ORCA_API void
luaX_pushPlaneMeshNode(lua_State *L, lpcPlaneMeshNode_t PlaneMeshNode);
/// @brief Check PlaneMeshNode form Lua stack at index.
ORCA_API lpPlaneMeshNode_t
luaX_checkPlaneMeshNode(lua_State *L, int idx);

typedef struct Camera Camera_t, *lpCamera_t;
typedef struct Camera const cCamera_t, *lpcCamera_t;
/// @brief Push Camera onto Lua stack.
ORCA_API void
luaX_pushCamera(lua_State *L, lpcCamera_t Camera);
/// @brief Check Camera form Lua stack at index.
ORCA_API lpCamera_t
luaX_checkCamera(lua_State *L, int idx);

typedef struct TrajectoryList3D TrajectoryList3D_t, *lpTrajectoryList3D_t;
typedef struct TrajectoryList3D const cTrajectoryList3D_t, *lpcTrajectoryList3D_t;
/// @brief Push TrajectoryList3D onto Lua stack.
ORCA_API void
luaX_pushTrajectoryList3D(lua_State *L, lpcTrajectoryList3D_t TrajectoryList3D);
/// @brief Check TrajectoryList3D form Lua stack at index.
ORCA_API lpTrajectoryList3D_t
luaX_checkTrajectoryList3D(lua_State *L, int idx);

typedef struct Viewport3D Viewport3D_t, *lpViewport3D_t;
typedef struct Viewport3D const cViewport3D_t, *lpcViewport3D_t;
/// @brief Push Viewport3D onto Lua stack.
ORCA_API void
luaX_pushViewport3D(lua_State *L, lpcViewport3D_t Viewport3D);
/// @brief Check Viewport3D form Lua stack at index.
ORCA_API lpViewport3D_t
luaX_checkViewport3D(lua_State *L, int idx);

typedef struct PrefabView3D PrefabView3D_t, *lpPrefabView3D_t;
typedef struct PrefabView3D const cPrefabView3D_t, *lpcPrefabView3D_t;
/// @brief Push PrefabView3D onto Lua stack.
ORCA_API void
luaX_pushPrefabView3D(lua_State *L, lpcPrefabView3D_t PrefabView3D);
/// @brief Check PrefabView3D form Lua stack at index.
ORCA_API lpPrefabView3D_t
luaX_checkPrefabView3D(lua_State *L, int idx);

typedef struct RenderPass RenderPass_t, *lpRenderPass_t;
typedef struct RenderPass const cRenderPass_t, *lpcRenderPass_t;
/// @brief Push RenderPass onto Lua stack.
ORCA_API void
luaX_pushRenderPass(lua_State *L, lpcRenderPass_t RenderPass);
/// @brief Check RenderPass form Lua stack at index.
ORCA_API lpRenderPass_t
luaX_checkRenderPass(lua_State *L, int idx);

typedef struct CompositionTargetRenderPass CompositionTargetRenderPass_t, *lpCompositionTargetRenderPass_t;
typedef struct CompositionTargetRenderPass const cCompositionTargetRenderPass_t, *lpcCompositionTargetRenderPass_t;
/// @brief Push CompositionTargetRenderPass onto Lua stack.
ORCA_API void
luaX_pushCompositionTargetRenderPass(lua_State *L, lpcCompositionTargetRenderPass_t CompositionTargetRenderPass);
/// @brief Check CompositionTargetRenderPass form Lua stack at index.
ORCA_API lpCompositionTargetRenderPass_t
luaX_checkCompositionTargetRenderPass(lua_State *L, int idx);

typedef struct BlitRenderPass BlitRenderPass_t, *lpBlitRenderPass_t;
typedef struct BlitRenderPass const cBlitRenderPass_t, *lpcBlitRenderPass_t;
/// @brief Push BlitRenderPass onto Lua stack.
ORCA_API void
luaX_pushBlitRenderPass(lua_State *L, lpcBlitRenderPass_t BlitRenderPass);
/// @brief Check BlitRenderPass form Lua stack at index.
ORCA_API lpBlitRenderPass_t
luaX_checkBlitRenderPass(lua_State *L, int idx);

typedef struct ClearRenderPass ClearRenderPass_t, *lpClearRenderPass_t;
typedef struct ClearRenderPass const cClearRenderPass_t, *lpcClearRenderPass_t;
/// @brief Push ClearRenderPass onto Lua stack.
ORCA_API void
luaX_pushClearRenderPass(lua_State *L, lpcClearRenderPass_t ClearRenderPass);
/// @brief Check ClearRenderPass form Lua stack at index.
ORCA_API lpClearRenderPass_t
luaX_checkClearRenderPass(lua_State *L, int idx);

typedef struct DrawObjectsRenderPass DrawObjectsRenderPass_t, *lpDrawObjectsRenderPass_t;
typedef struct DrawObjectsRenderPass const cDrawObjectsRenderPass_t, *lpcDrawObjectsRenderPass_t;
/// @brief Push DrawObjectsRenderPass onto Lua stack.
ORCA_API void
luaX_pushDrawObjectsRenderPass(lua_State *L, lpcDrawObjectsRenderPass_t DrawObjectsRenderPass);
/// @brief Check DrawObjectsRenderPass form Lua stack at index.
ORCA_API lpDrawObjectsRenderPass_t
luaX_checkDrawObjectsRenderPass(lua_State *L, int idx);

typedef struct PipelineStateRenderPass PipelineStateRenderPass_t, *lpPipelineStateRenderPass_t;
typedef struct PipelineStateRenderPass const cPipelineStateRenderPass_t, *lpcPipelineStateRenderPass_t;
/// @brief Push PipelineStateRenderPass onto Lua stack.
ORCA_API void
luaX_pushPipelineStateRenderPass(lua_State *L, lpcPipelineStateRenderPass_t PipelineStateRenderPass);
/// @brief Check PipelineStateRenderPass form Lua stack at index.
ORCA_API lpPipelineStateRenderPass_t
luaX_checkPipelineStateRenderPass(lua_State *L, int idx);

typedef struct TextBlock3D TextBlock3D_t, *lpTextBlock3D_t;
typedef struct TextBlock3D const cTextBlock3D_t, *lpcTextBlock3D_t;
/// @brief Push TextBlock3D onto Lua stack.
ORCA_API void
luaX_pushTextBlock3D(lua_State *L, lpcTextBlock3D_t TextBlock3D);
/// @brief Check TextBlock3D form Lua stack at index.
ORCA_API lpTextBlock3D_t
luaX_checkTextBlock3D(lua_State *L, int idx);

typedef struct Light3D Light3D_t, *lpLight3D_t;
typedef struct Light3D const cLight3D_t, *lpcLight3D_t;
/// @brief Push Light3D onto Lua stack.
ORCA_API void
luaX_pushLight3D(lua_State *L, lpcLight3D_t Light3D);
/// @brief Check Light3D form Lua stack at index.
ORCA_API lpLight3D_t
luaX_checkLight3D(lua_State *L, int idx);

typedef struct SpriteView SpriteView_t, *lpSpriteView_t;
typedef struct SpriteView const cSpriteView_t, *lpcSpriteView_t;
/// @brief Push SpriteView onto Lua stack.
ORCA_API void
luaX_pushSpriteView(lua_State *L, lpcSpriteView_t SpriteView);
/// @brief Check SpriteView form Lua stack at index.
ORCA_API lpSpriteView_t
luaX_checkSpriteView(lua_State *L, int idx);

#include <source/renderer/api/renderer.h>
#include <include/renderer.h>
#include <source/UIKit/UIKit.h>
typedef enum StencilOp {
	kStencilOpKeep, /// Keep the current stencil buffer value unchanged
	kStencilOpZero, /// Set the stencil buffer value to zero
	kStencilOpReplace, /// Replace stencil buffer value with the reference value
	kStencilOpIncrement, /// Increment stencil buffer value, clamping to maximum
	kStencilOpIncrementWrap, /// Increment stencil buffer value, wrapping to zero at maximum
	kStencilOpDecrement, /// Decrement stencil buffer value, clamping to zero
	kStencilOpDecrementWrap, /// Decrement stencil buffer value, wrapping to maximum at zero
	kStencilOpInvert, /// Bitwise invert the stencil buffer value
} eStencilOp_t;

typedef enum ViewportMode {
	kViewportModeRelative, /// Coordinates specified as normalized values (0.0 to 1.0) relative to render target size
	kViewportModeAbsolute, /// Coordinates specified in absolute pixels
} eViewportMode_t;

typedef enum CullMode {
	kCullModeNone, /// No face culling - render both front and back faces
	kCullModeBack, /// Cull back-facing triangles (standard for solid objects)
	kCullModeFront, /// Cull front-facing triangles (useful for interior views or special effects)
} eCullMode_t;

typedef enum ColorWriteMode {
	kColorWriteModeNone, /// Disable all color channel writes (useful for depth-only or stencil-only passes)
	kColorWriteModeRGB, /// Write to red, green, and blue channels only
	kColorWriteModeRGBA, /// Write to all four color channels including alpha
	kColorWriteModeR, /// Write to red channel only
	kColorWriteModeG, /// Write to green channel only
	kColorWriteModeB, /// Write to blue channel only
	kColorWriteModeGB, /// Write to green and blue channels only
	kColorWriteModeA, /// Write to alpha channel only
} eColorWriteMode_t;

typedef enum FovType {
	kFovTypeXfov, /// Field of view specified as horizontal angle in degrees
	kFovTypeYfov, /// Field of view specified as vertical angle in degrees (most common)
} eFovType_t;

typedef enum ProjectionType {
	kProjectionTypePerspective, /// Perspective projection with realistic depth foreshortening
	kProjectionTypeOrthographic, /// Orthographic projection with parallel lines (no perspective distortion)
} eProjectionType_t;

typedef enum LightType {
	kLightTypePoint, /// Omnidirectional point light source (like a light bulb)
	kLightTypeSpot, /// Directional spot light with cone-shaped illumination area
} eLightType_t;

typedef struct Node3D Node3D, *Node3DPtr;
typedef struct Node3D const *Node3DCPtr;
/// @brief Base class for all 3D scene graph nodes with transform and positioning capabilities
struct Node3D {
	transform3_t LayoutTransform; /// Transform applied during layout phase for positioning within parent containers
	transform3_t RenderTransform; /// Additional transform applied during rendering for animations and effects
	vec3_t RenderTransformOrigin; /// Origin point for render transform operations (rotation, scaling center)
	vec3_t ContentOffset; /// Offset applied to child content within this node's local coordinate system
	mat4_t Matrix; /// Final combined transformation matrix (computed automatically)
	float CalculatedOffset; /// Computed offset value used for trajectory list positioning
	float _opacity;
};

typedef struct Scene Scene, *ScenePtr;
typedef struct Scene const *SceneCPtr;
/// @brief Root container for 3D scene content with camera and rendering configuration
struct Scene {
	fixedString_t Camera; /// Name of the primary camera used for scene rendering
	fixedString_t PreviewCamera; /// Name of camera used for preview rendering in design tools
	fixedString_t HitTestCamera; /// Name of camera used for 3D hit testing and mouse interaction
	lpRenderPass_t RenderPass; /// Custom render pass chain for advanced rendering effects
	fixedString_t BackgroundTimelineSequence; /// TODO: add support?
	lpRenderPass_t ComposerOverride; /// Override render pass for post-processing composition effects
	lpTexture_t EnvironmentTexture; /// Environment map texture for reflections and ambient lighting
};

typedef struct Model3D Model3D, *Model3DPtr;
typedef struct Model3D const *Model3DCPtr;
/// @brief 3D model renderer that displays mesh geometry with materials
struct Model3D {
	lpMesh_t Mesh; /// 3D mesh geometry defining the shape of the model
	lpMaterial_t Material; /// Material defining surface appearance, textures, and shading properties
};

typedef struct PlaneMeshNode PlaneMeshNode, *PlaneMeshNodePtr;
typedef struct PlaneMeshNode const *PlaneMeshNodeCPtr;
/// @brief Procedural plane mesh generator for creating rectangular surfaces
struct PlaneMeshNode {
	float PlaneWidth; /// Width of the generated plane in world units
	float PlaneHeight; /// Height of the generated plane in world units
	bool_t PlaneInvertU; /// Invert horizontal texture coordinates (flip texture horizontally)
	bool_t PlaneInvertV; /// Invert vertical texture coordinates (flip texture vertically)
	bool_t GenerateTangents; /// Generate tangent vectors for normal mapping (requires additional memory)
	bool_t GenerateNormals; /// Generate vertex normals for proper lighting (usually true for lit surfaces)
	lpMaterial_t MeshMaterial; /// Override material specifically for the generated mesh geometry
};

typedef struct Camera Camera, *CameraPtr;
typedef struct Camera const *CameraCPtr;
/// @brief 3D camera for scene viewing and projection configuration
struct Camera {
	float Fov; /// Field of view angle in degrees (60-90 typical for perspective cameras)
	eFovType_t FovType; /// Whether field of view is measured horizontally or vertically
	eProjectionType_t ProjectionType; /// Perspective or orthographic projection mode
	float ZNear; /// Near clipping plane distance (objects closer than this are not rendered)
	float ZFar; /// Far clipping plane distance (objects farther than this are not rendered)
	float EyeSeparation; /// Distance between left and right eyes for stereoscopic rendering
	float FocalDistance; /// Focus distance for depth of field and stereo convergence
	float OrthogonalPlaneHeight; /// Height of viewing volume for orthographic projection
	bool_t ZPositive; /// Whether positive Z axis points toward or away from viewer
};

typedef struct TrajectoryList3D TrajectoryList3D, *TrajectoryList3DPtr;
typedef struct TrajectoryList3D const *TrajectoryList3DCPtr;
/// @brief Layout container that arranges child nodes along a 3D trajectory path
struct TrajectoryList3D {
	lpTrajectory_t Trajectory; /// 3D path shape defining the trajectory curve for child positioning
	vec2_t ScrollAxis; /// Primary and secondary scroll directions for trajectory navigation
	bool_t Looping; /// Whether trajectory wraps around at the ends (creates infinite loop)
	float Spacing; /// Distance between adjacent items along the trajectory path
	float SelectionBehavior; /// Controls how selection affects item positioning and scaling
	float SelectedItemIndex; /// Index of currently selected item (supports fractional values for smooth transitions)
};

typedef struct Viewport3D Viewport3D, *Viewport3DPtr;
typedef struct Viewport3D const *Viewport3DCPtr;
/// @brief 2D viewport component that renders 3D scene content
struct Viewport3D {
	fixedString_t Camera; /// Name of camera to use for 3D scene rendering within this viewport
	fixedString_t PreviewCamera; /// Name of camera used for design-time preview rendering
	fixedString_t HitTestCamera; /// Name of camera used for 3D hit testing within the viewport area
	lpRenderPass_t RenderPass; /// Custom render pass chain for viewport-specific effects
	fixedString_t Scene; /// TODO: add support?
};

typedef struct PrefabView3D PrefabView3D, *PrefabView3DPtr;
typedef struct PrefabView3D const *PrefabView3DCPtr;
/// @brief Dynamic loader for 3D prefab assets and scene files
struct PrefabView3D {
	fixedString_t SCA; /// Adds "hmi_plugins/{{SCA}}" to search paths and loads from "prefabs/{{SCA}}"
	fixedString_t Prefab; /// Path to prefab asset file to instantiate
	int32_t _loadedSCA;
	int32_t _loadedPrefab;
};

typedef struct RenderPass RenderPass, *RenderPassPtr;
typedef struct RenderPass const *RenderPassCPtr;
/// @brief Base class for render pass components in the rendering pipeline
struct RenderPass {
};

typedef struct CompositionTargetRenderPass CompositionTargetRenderPass, *CompositionTargetRenderPassPtr;
typedef struct CompositionTargetRenderPass const *CompositionTargetRenderPassCPtr;
/// @brief Render pass that outputs to the final composition target
struct CompositionTargetRenderPass {
};

typedef struct BlitRenderPass BlitRenderPass, *BlitRenderPassPtr;
typedef struct BlitRenderPass const *BlitRenderPassCPtr;
/// @brief Render pass for copying (blitting) between render targets
struct BlitRenderPass {
};

typedef struct ClearRenderPass ClearRenderPass, *ClearRenderPassPtr;
typedef struct ClearRenderPass const *ClearRenderPassCPtr;
/// @brief Render pass for clearing framebuffer contents
struct ClearRenderPass {
	color_t ClearColor; /// Color value to clear the color buffer (RGBA format)
	float ClearDepth; /// Depth value to clear the depth buffer (typically 1.0 for far plane)
	int32_t ClearStencil; /// Integer value to clear the stencil buffer (typically 0)
};

typedef struct DrawObjectsRenderPass DrawObjectsRenderPass, *DrawObjectsRenderPassPtr;
typedef struct DrawObjectsRenderPass const *DrawObjectsRenderPassCPtr;
/// @brief Render pass for drawing scene objects with tag-based filtering
struct DrawObjectsRenderPass {
	fixedString_t Camera; /// Name of camera to use for object rendering and view/projection matrices
	objectTags_t IncludeTags; /// Object tags that must be present for objects to be rendered
	objectTags_t ExcludeTags; /// Object tags that prevent objects from being rendered
};

typedef struct PipelineStateRenderPass PipelineStateRenderPass, *PipelineStateRenderPassPtr;
typedef struct PipelineStateRenderPass const *PipelineStateRenderPassCPtr;
/// @brief Render pass for configuring graphics pipeline state
struct PipelineStateRenderPass {
	eBlendMode_t BlendMode; /// Color blending mode for transparency and compositing effects
	eColorWriteMode_t ColorWriteMode; /// Which color channels are written to the framebuffer
	eCullMode_t CullMode; /// Triangle face culling mode for performance optimization
	eCompareFunc_t DepthTestFunction; /// Comparison function for depth buffer testing
	bool_t DepthWriteEnabled; /// Whether to write depth values to the depth buffer
	eViewportMode_t ViewportMode; /// Coordinate system for viewport rectangle specification
	eViewportMode_t ScissorMode; /// Coordinate system for scissor rectangle specification
	vec4_t Viewport; /// Viewport rectangle (x, y, width, height) for rendering area
	vec4_t Scissor; /// Scissor rectangle (x, y, width, height) for pixel clipping
	eCompareFunc_t StencilTestFunction; /// Comparison function for stencil buffer testing
	int32_t StencilReferenceValue; /// Reference value used in stencil test comparisons
	int32_t StencilMask; /// Bitmask applied to stencil values before testing
	eStencilOp_t StencilFailOperation; /// Operation when stencil test fails
	eStencilOp_t StencilPassDepthFailOperation; /// Operation when stencil test passes but depth test fails
	eStencilOp_t StencilPassDepthPassOperation; /// Operation when both stencil and depth tests pass
	bool_t StencilWriteEnabled; /// Whether to write computed stencil values to the stencil buffer
};

typedef struct TextBlock3D TextBlock3D, *TextBlock3DPtr;
typedef struct TextBlock3D const *TextBlock3DCPtr;
/// @brief 3D text renderer for displaying typography in 3D space
struct TextBlock3D {
	lpNode3D_t _node3D;
};

typedef struct Light3D Light3D, *Light3DPtr;
typedef struct Light3D const *Light3DCPtr;
/// @brief 3D light source for scene illumination and shadow casting
struct Light3D {
	color_t Color; /// RGB color and intensity of the light emission
	vec2_t SpotAngle; /// Inner and outer cone angles for spot lights (X=inner, Y=outer in degrees)
	float Intensity; /// Brightness multiplier for light output (1.0 = normal intensity)
	float Range; /// Maximum distance at which light affects surfaces (for performance optimization)
	eLightType_t Type; /// Type of light source (point or spot)
};

typedef struct SpriteView SpriteView, *SpriteViewPtr;
typedef struct SpriteView const *SpriteViewCPtr;
/// @brief Billboard sprite renderer for 2D images in 3D space
struct SpriteView {
	lpTexture_t Image; /// 2D image texture to display on the billboard sprite
	vec4_t Bounds; /// Texture coordinates and sizing (X=U, Y=V, Z=width, W=height)
};

#endif
