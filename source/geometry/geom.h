// Generated by XSLT code generator
#ifndef __GEOMETRY_H__
#define __GEOMETRY_H__

#include <include/orca.h>

typedef struct vec2 vec2_t;
typedef struct vec3 vec3_t;
typedef struct vec4 vec4_t;
typedef struct box2 box2_t;
typedef struct box3 box3_t;
typedef struct rect rect_t;
typedef struct quat quat_t;
typedef struct mat3 mat3_t;
typedef struct mat4 mat4_t;
typedef struct bounds bounds_t;
typedef struct plane3 plane3_t;
typedef struct sphere3 sphere3_t;
typedef struct frustum3 frustum3_t;
typedef struct transform2 transform2_t;
typedef struct transform3 transform3_t;
typedef struct triangle3 triangle3_t;
typedef struct line3 line3_t;
typedef struct edges edges_t;
typedef struct color color_t;

// 2D vector structure
struct vec2 {
    float x;
    float y;
};

void vec2_Set(vec2_t* self, float x, float y);

vec2 vec2_Scale(const vec2_t* self, float s);

vec2 vec2_Add(const vec2_t* self, const vec2* other);

vec2 vec2_Mul(const vec2_t* self, const vec2* other);

vec2 vec2_Div(const vec2_t* self, const vec2* other);

vec2 vec2_Sub(const vec2_t* self, const vec2* other);

vec2 vec2_Unm(const vec2_t* self);

float vec2_Dot(const vec2_t* self, const vec2* other);

float vec2_Lengthsq(const vec2_t* self);

float vec2_Len(const vec2_t* self);

float vec2_Distance(const vec2_t* self, const vec2* other);

void vec2_Normalize(vec2_t* self);

vec2 vec2_Lerp(const vec2_t* self, const vec2* other, float t);

vec2 vec2_Mad(const vec2_t* self, float s, const vec2* other);

// 3D vector structure
struct vec3 {
    float x;
    float y;
    float z;
};

float vec3_Dot(const vec3_t* self, const vec3* other);

float vec3_Lengthsq(const vec3_t* self);

float vec3_Len(const vec3_t* self);

vec3 vec3_Bezier(const vec3_t* self, const vec3* b, const vec3* c, const vec3* d, float t);

vec3 vec3_Hermite(const vec3_t* self, const vec3* b, const vec3* c, const vec3* d, float t);

vec3 vec3_Lerp(const vec3_t* self, const vec3* other, float t);

vec3 vec3_Cross(const vec3_t* self, const vec3* other);

vec3 vec3_Sub(const vec3_t* self, const vec3* other);

vec3 vec3_Add(const vec3_t* self, const vec3* other);

vec3 vec3_Mad(const vec3_t* self, float s, const vec3* other);

vec3 vec3_Mul(const vec3_t* self, const vec3* other);

vec3 vec3_Scale(const vec3_t* self, float s);

void vec3_Normalize(vec3_t* self);

void vec3_Set(vec3_t* self, float x, float y, float z);

void vec3_Clear(vec3_t* self);

vec3 vec3_Unm(const vec3_t* self);

float vec3_Distance(const vec3_t* self, const vec3* other);

// 4D vector structure
struct vec4 {
    float x;
    float y;
    float z;
    float w;
};

void vec4_Set(vec4_t* self, float x, float y, float z, float w);

vec4 vec4_Scale(const vec4_t* self, float s);

vec4 vec4_Add(const vec4_t* self, const vec4* other);

vec4 vec4_Unm(const vec4_t* self);

vec4 vec4_Lerp(const vec4_t* self, const vec4* other, float t);

// 2D axis-aligned bounding box
struct box2 {
    vec2 min;
    vec2 max;
};

vec2 box2_Center(const box2_t* self);

void box2_MoveTo(box2_t* self, const vec2* location);

bool box2_ContainsPoint(const box2_t* self, const vec2* point);

// 3D axis-aligned bounding box
struct box3 {
    vec3 min;
    vec3 max;
};

vec3 box3_Center(const box3_t* self);

// 2D rectangle structure
struct rect {
    float x;
    float y;
    float width;
    float height;
};

bool rect_Contains(const rect_t* self, const vec2* point);

rect rect_Scale(const rect_t* self, float scale);

rect rect_Expand(const rect_t* self, float padding);

vec2 rect_Center(const rect_t* self);

rect rect_Fit(const rect_t* self, const vec2* big);

// Quaternion for 3D rotations
struct quat {
    float x;
    float y;
    float z;
    float w;
};

quat quat_FromEuler(quat_t* self, const vec3* euler, RotationOrder order);

quat quat_FromMatrix(quat_t* self, const mat4* matrix);

float quat_DotProduct(const quat_t* self, const quat* other);

float quat_Length(const quat_t* self);

quat quat_Unm(const quat_t* self);

quat quat_Normalized(const quat_t* self);

quat quat_Slerp(const quat_t* self, const quat* q, float t);

quat quat_Sqlerp(const quat_t* self, const quat* b, const quat* c, const quat* d, float t);

// 3x3 transformation matrix
struct mat3 {
    float v[9];
};

mat3 mat3_Identity(mat3_t* self);

mat3 mat3_Normal(mat3_t* self, const mat4* matrix);

void mat3_Translate(mat3_t* self, const vec2* offset);

void mat3_Scale(mat3_t* self, const vec2* scale);

// 4x4 transformation matrix
struct mat4 {
    float v[16];
};

mat4 mat4_Identity(mat4_t* self);

void mat4_Translate(mat4_t* self, const vec3* offset);

void mat4_Rotate(mat4_t* self, const vec3* euler, RotationOrder order);

void mat4_Scale(mat4_t* self, const vec3* scale);

mat4 mat4_Multiply(const mat4_t* self, const mat4* other);

mat4 mat4_Ortho(mat4_t* self, float left, float right, float bottom, float top, float znear, float zfar);

mat4 mat4_Perspective(mat4_t* self, float radians, float aspect, float znear, float zfar);

mat4 mat4_LookAt(mat4_t* self, const vec3* eye, const vec3* direction, const vec3* up);

mat4 mat4_Inverse(const mat4_t* self);

mat4 mat4_Transpose(const mat4_t* self);

void mat4_Rotate4(mat4_t* self, const vec4* quat);

vec3 mat4_MultiplyVector3D(const mat4_t* self, const vec3* point);

mat4 mat4_FromRotationOrigin(mat4_t* self, const quat* rotation, const vec3* origin);

mat4 mat4_FromRotationTranslationScaleOrigin(mat4_t* self, const quat* rotation, const vec3* translation, const vec3* scale, const vec3* origin);

mat4 mat4_FromTranslation(mat4_t* self, const vec3* translation);

void mat4_RotateQuat(mat4_t* self, const quat* rotation);

// 1D range bounds
struct bounds {
    float min;
    float max;
};

// 3D plane representation
struct plane3 {
    float a;
    float b;
    float c;
    float d;
};

void plane3_Normalize(plane3_t* self);

float plane3_MultiplyVector3D(const plane3_t* self, const vec3* point);

// 3D sphere representation
struct sphere3 {
    vec3 center;
    float radius;
};

// 3D viewing frustum
struct frustum3 {
    plane3 left;
    plane3 right;
    plane3 bottom;
    plane3 top;
    plane3 front;
    plane3 back;
};

frustum3 frustum3_Calculate(frustum3_t* self, const mat4* matrix);

bool frustum3_ContainsPoint(const frustum3_t* self, const vec3* point);

bool frustum3_ContainsSphere(const frustum3_t* self, const sphere3* sphere);

bool frustum3_ContainsBox(const frustum3_t* self, const box3* box, const mat4* matrix);

bool frustum3_ContainsAABox(const frustum3_t* self, const box3* box);

// 2D transformation structure
struct transform2 {
    vec2 translation;
    float rotation;
    vec2 scale;
};

transform2 transform2_Identity(transform2_t* self);

mat4 transform2_ToMatrix3D(const transform2_t* self, const vec2* pivot);

// 3D transformation structure
struct transform3 {
    vec3 translation;
    vec3 rotation;
    vec3 scale;
};

transform3 transform3_Identity(transform3_t* self);

mat4 transform3_ToMatrix3D(const transform3_t* self, const vec3* pivot);

// 3D triangle primitive
struct triangle3 {
    vec3 a;
    vec3 b;
    vec3 c;
};

vec3 triangle3_normal(const triangle3_t* self);

// 3D line segment
struct line3 {
    vec3 a;
    vec3 b;
};

bool line3_intersect_sphere3(const line3_t* self, const sphere3* sphere, vec3* out);

bool line3_intersect_plane3(const line3_t* self, const plane3* plane, vec3* out);

bool line3_intersect_triangle(const line3_t* self, const triangle3* triangle, vec3* out);

bool line3_intersect_box3(const line3_t* self, const box3* box, vec3* out);

// Edge insets structure
struct edges {
    float left;
    float top;
    float right;
    float bottom;
};

// RGBA color representation
struct color {
    float r;
    float g;
    float b;
    float a;
};

color color_Lerp(const color_t* self, const color* other, float t);

color color_Parse(color_t* self, string code);

#endif
