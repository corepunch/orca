// Generated by codegen utility
#ifndef __GEOMETRY_H__
#define __GEOMETRY_H__

#include <include/orca.h>

typedef struct vec2 vec2_t, *lpvec2_t;
typedef struct vec2 const cvec2_t, *lpcvec2_t;
/// @brief Push vec2 onto Lua stack.
ORCA_API void
luaX_pushvec2(lua_State *L, lpcvec2_t vec2);
/// @brief Check vec2 form Lua stack at index.
ORCA_API lpvec2_t
luaX_checkvec2(lua_State *L, int idx);

typedef struct vec3 vec3_t, *lpvec3_t;
typedef struct vec3 const cvec3_t, *lpcvec3_t;
/// @brief Push vec3 onto Lua stack.
ORCA_API void
luaX_pushvec3(lua_State *L, lpcvec3_t vec3);
/// @brief Check vec3 form Lua stack at index.
ORCA_API lpvec3_t
luaX_checkvec3(lua_State *L, int idx);

typedef struct vec4 vec4_t, *lpvec4_t;
typedef struct vec4 const cvec4_t, *lpcvec4_t;
/// @brief Push vec4 onto Lua stack.
ORCA_API void
luaX_pushvec4(lua_State *L, lpcvec4_t vec4);
/// @brief Check vec4 form Lua stack at index.
ORCA_API lpvec4_t
luaX_checkvec4(lua_State *L, int idx);

typedef struct box2 box2_t, *lpbox2_t;
typedef struct box2 const cbox2_t, *lpcbox2_t;
/// @brief Push box2 onto Lua stack.
ORCA_API void
luaX_pushbox2(lua_State *L, lpcbox2_t box2);
/// @brief Check box2 form Lua stack at index.
ORCA_API lpbox2_t
luaX_checkbox2(lua_State *L, int idx);

typedef struct box3 box3_t, *lpbox3_t;
typedef struct box3 const cbox3_t, *lpcbox3_t;
/// @brief Push box3 onto Lua stack.
ORCA_API void
luaX_pushbox3(lua_State *L, lpcbox3_t box3);
/// @brief Check box3 form Lua stack at index.
ORCA_API lpbox3_t
luaX_checkbox3(lua_State *L, int idx);

typedef struct rect rect_t, *lprect_t;
typedef struct rect const crect_t, *lpcrect_t;
/// @brief Push rect onto Lua stack.
ORCA_API void
luaX_pushrect(lua_State *L, lpcrect_t rect);
/// @brief Check rect form Lua stack at index.
ORCA_API lprect_t
luaX_checkrect(lua_State *L, int idx);

typedef struct quat quat_t, *lpquat_t;
typedef struct quat const cquat_t, *lpcquat_t;
/// @brief Push quat onto Lua stack.
ORCA_API void
luaX_pushquat(lua_State *L, lpcquat_t quat);
/// @brief Check quat form Lua stack at index.
ORCA_API lpquat_t
luaX_checkquat(lua_State *L, int idx);

typedef struct mat3 mat3_t, *lpmat3_t;
typedef struct mat3 const cmat3_t, *lpcmat3_t;
/// @brief Push mat3 onto Lua stack.
ORCA_API void
luaX_pushmat3(lua_State *L, lpcmat3_t mat3);
/// @brief Check mat3 form Lua stack at index.
ORCA_API lpmat3_t
luaX_checkmat3(lua_State *L, int idx);

typedef struct mat4 mat4_t, *lpmat4_t;
typedef struct mat4 const cmat4_t, *lpcmat4_t;
/// @brief Push mat4 onto Lua stack.
ORCA_API void
luaX_pushmat4(lua_State *L, lpcmat4_t mat4);
/// @brief Check mat4 form Lua stack at index.
ORCA_API lpmat4_t
luaX_checkmat4(lua_State *L, int idx);

typedef struct bounds bounds_t, *lpbounds_t;
typedef struct bounds const cbounds_t, *lpcbounds_t;
/// @brief Push bounds onto Lua stack.
ORCA_API void
luaX_pushbounds(lua_State *L, lpcbounds_t bounds);
/// @brief Check bounds form Lua stack at index.
ORCA_API lpbounds_t
luaX_checkbounds(lua_State *L, int idx);

typedef struct plane3 plane3_t, *lpplane3_t;
typedef struct plane3 const cplane3_t, *lpcplane3_t;
/// @brief Push plane3 onto Lua stack.
ORCA_API void
luaX_pushplane3(lua_State *L, lpcplane3_t plane3);
/// @brief Check plane3 form Lua stack at index.
ORCA_API lpplane3_t
luaX_checkplane3(lua_State *L, int idx);

typedef struct sphere3 sphere3_t, *lpsphere3_t;
typedef struct sphere3 const csphere3_t, *lpcsphere3_t;
/// @brief Push sphere3 onto Lua stack.
ORCA_API void
luaX_pushsphere3(lua_State *L, lpcsphere3_t sphere3);
/// @brief Check sphere3 form Lua stack at index.
ORCA_API lpsphere3_t
luaX_checksphere3(lua_State *L, int idx);

typedef struct frustum3 frustum3_t, *lpfrustum3_t;
typedef struct frustum3 const cfrustum3_t, *lpcfrustum3_t;
/// @brief Push frustum3 onto Lua stack.
ORCA_API void
luaX_pushfrustum3(lua_State *L, lpcfrustum3_t frustum3);
/// @brief Check frustum3 form Lua stack at index.
ORCA_API lpfrustum3_t
luaX_checkfrustum3(lua_State *L, int idx);

typedef struct transform2 transform2_t, *lptransform2_t;
typedef struct transform2 const ctransform2_t, *lpctransform2_t;
/// @brief Push transform2 onto Lua stack.
ORCA_API void
luaX_pushtransform2(lua_State *L, lpctransform2_t transform2);
/// @brief Check transform2 form Lua stack at index.
ORCA_API lptransform2_t
luaX_checktransform2(lua_State *L, int idx);

typedef struct transform3 transform3_t, *lptransform3_t;
typedef struct transform3 const ctransform3_t, *lpctransform3_t;
/// @brief Push transform3 onto Lua stack.
ORCA_API void
luaX_pushtransform3(lua_State *L, lpctransform3_t transform3);
/// @brief Check transform3 form Lua stack at index.
ORCA_API lptransform3_t
luaX_checktransform3(lua_State *L, int idx);

typedef struct triangle3 triangle3_t, *lptriangle3_t;
typedef struct triangle3 const ctriangle3_t, *lpctriangle3_t;
/// @brief Push triangle3 onto Lua stack.
ORCA_API void
luaX_pushtriangle3(lua_State *L, lpctriangle3_t triangle3);
/// @brief Check triangle3 form Lua stack at index.
ORCA_API lptriangle3_t
luaX_checktriangle3(lua_State *L, int idx);

typedef struct line3 line3_t, *lpline3_t;
typedef struct line3 const cline3_t, *lpcline3_t;
/// @brief Push line3 onto Lua stack.
ORCA_API void
luaX_pushline3(lua_State *L, lpcline3_t line3);
/// @brief Check line3 form Lua stack at index.
ORCA_API lpline3_t
luaX_checkline3(lua_State *L, int idx);

typedef struct edges edges_t, *lpedges_t;
typedef struct edges const cedges_t, *lpcedges_t;
/// @brief Push edges onto Lua stack.
ORCA_API void
luaX_pushedges(lua_State *L, lpcedges_t edges);
/// @brief Check edges form Lua stack at index.
ORCA_API lpedges_t
luaX_checkedges(lua_State *L, int idx);

typedef struct color color_t, *lpcolor_t;
typedef struct color const ccolor_t, *lpccolor_t;
/// @brief Push color onto Lua stack.
ORCA_API void
luaX_pushcolor(lua_State *L, lpccolor_t color);
/// @brief Check color form Lua stack at index.
ORCA_API lpcolor_t
luaX_checkcolor(lua_State *L, int idx);

typedef enum RotationOrder {
	kRotationOrderXYZ, /// Rotate around X axis first, then Y, then Z
	kRotationOrderXZY, /// Rotate around X axis first, then Z, then Y
	kRotationOrderYZX, /// Rotate around Y axis first, then Z, then X
	kRotationOrderYXZ, /// Rotate around Y axis first, then X, then Z
	kRotationOrderZXY, /// Rotate around Z axis first, then X, then Y
	kRotationOrderZYX, /// Rotate around Z axis first, then Y, then X
} eRotationOrder_t;

/// @brief 2D vector structure
struct vec2 {
	float x; /// X coordinate component
	float y; /// Y coordinate component
};

/// @brief Sets the vector components
ORCA_API void
VEC2_Set(lpvec2_t self, float x, float y);

/// @brief Returns a scaled copy of the vector
ORCA_API vec2_t
VEC2_Scale(lpcvec2_t self, float s);

/// @brief Adds two vectors component-wise
ORCA_API vec2_t
VEC2_Add(lpcvec2_t self, lpcvec2_t other);

/// @brief Multiplies two vectors component-wise
ORCA_API vec2_t
VEC2_Mul(lpcvec2_t self, lpcvec2_t other);

/// @brief Divides two vectors component-wise
ORCA_API vec2_t
VEC2_Div(lpcvec2_t self, lpcvec2_t other);

/// @brief Subtracts one vector from another
ORCA_API vec2_t
VEC2_Sub(lpcvec2_t self, lpcvec2_t other);

/// @brief Returns the negated vector
ORCA_API vec2_t
VEC2_Unm(lpcvec2_t self);

/// @brief Calculates dot product with another vector
ORCA_API float
VEC2_Dot(lpcvec2_t self, lpcvec2_t other);

/// @brief Returns the squared length of the vector
ORCA_API float
VEC2_Lengthsq(lpcvec2_t self);

/// @brief Returns the length (magnitude) of the vector
ORCA_API float
VEC2_Len(lpcvec2_t self);

/// @brief Calculates distance to another vector
ORCA_API float
VEC2_Distance(lpcvec2_t self, lpcvec2_t other);

/// @brief Normalizes the vector in place to unit length
ORCA_API void
VEC2_Normalize(lpvec2_t self);

/// @brief Linear interpolation between this vector and another
ORCA_API vec2_t
VEC2_Lerp(lpcvec2_t self, lpcvec2_t other, float t);

/// @brief Multiply-add operation: returns this + (s * other)
ORCA_API vec2_t
VEC2_Mad(lpcvec2_t self, float s, lpcvec2_t other);

/// @brief 3D vector structure
struct vec3 {
	float x; /// X coordinate component
	float y; /// Y coordinate component
	float z; /// Z coordinate component
};

/// @brief Calculates dot product with another vector
ORCA_API float
VEC3_Dot(lpcvec3_t self, lpcvec3_t other);

/// @brief Returns the squared length of the vector
ORCA_API float
VEC3_Lengthsq(lpcvec3_t self);

/// @brief Returns the length (magnitude) of the vector
ORCA_API float
VEC3_Len(lpcvec3_t self);

/// @brief Cubic Bezier curve interpolation
ORCA_API vec3_t
VEC3_Bezier(lpcvec3_t self, lpcvec3_t b, lpcvec3_t c, lpcvec3_t d, float t);

/// @brief Hermite spline interpolation
ORCA_API vec3_t
VEC3_Hermite(lpcvec3_t self, lpcvec3_t b, lpcvec3_t c, lpcvec3_t d, float t);

/// @brief Linear interpolation between this vector and another
ORCA_API vec3_t
VEC3_Lerp(lpcvec3_t self, lpcvec3_t other, float t);

/// @brief Calculates cross product with another vector
ORCA_API vec3_t
VEC3_Cross(lpcvec3_t self, lpcvec3_t other);

/// @brief Subtracts one vector from another
ORCA_API vec3_t
VEC3_Sub(lpcvec3_t self, lpcvec3_t other);

/// @brief Adds two vectors component-wise
ORCA_API vec3_t
VEC3_Add(lpcvec3_t self, lpcvec3_t other);

/// @brief Multiply-add operation: returns this + (s * other)
ORCA_API vec3_t
VEC3_Mad(lpcvec3_t self, float s, lpcvec3_t other);

/// @brief Multiplies two vectors component-wise
ORCA_API vec3_t
VEC3_Mul(lpcvec3_t self, lpcvec3_t other);

/// @brief Returns a scaled copy of the vector
ORCA_API vec3_t
VEC3_Scale(lpcvec3_t self, float s);

/// @brief Normalizes the vector in place to unit length
ORCA_API void
VEC3_Normalize(lpvec3_t self);

/// @brief Sets the vector components
ORCA_API void
VEC3_Set(lpvec3_t self, float x, float y, float z);

/// @brief Sets all components to zero
ORCA_API void
VEC3_Clear(lpvec3_t self);

/// @brief Returns the negated vector
ORCA_API vec3_t
VEC3_Unm(lpcvec3_t self);

/// @brief Calculates distance to another vector
ORCA_API float
VEC3_Distance(lpcvec3_t self, lpcvec3_t other);

/// @brief 4D vector structure
struct vec4 {
	float x; /// X coordinate component
	float y; /// Y coordinate component
	float z; /// Z coordinate component
	float w; /// W coordinate component
};

/// @brief Sets all vector components
ORCA_API void
VEC4_Set(lpvec4_t self, float x, float y, float z, float w);

/// @brief Returns a scaled copy of the vector
ORCA_API vec4_t
VEC4_Scale(lpcvec4_t self, float s);

/// @brief Adds two vectors component-wise
ORCA_API vec4_t
VEC4_Add(lpcvec4_t self, lpcvec4_t other);

/// @brief Returns the negated vector
ORCA_API vec4_t
VEC4_Unm(lpcvec4_t self);

/// @brief Linear interpolation between this vector and another
ORCA_API vec4_t
VEC4_Lerp(lpcvec4_t self, lpcvec4_t other, float t);

/// @brief 2D axis-aligned bounding box
struct box2 {
	vec2_t min; /// Minimum corner point (bottom-left)
	vec2_t max; /// Maximum corner point (top-right)
};

/// @brief Calculates the center point of the box
ORCA_API vec2_t
BOX2_Center(lpcbox2_t self);

/// @brief Moves the box so its center is at the specified location
ORCA_API void
BOX2_MoveTo(lpbox2_t self, lpcvec2_t location);

/// @brief Tests if a point is inside the box
ORCA_API bool_t
BOX2_ContainsPoint(lpcbox2_t self, lpcvec2_t point);

/// @brief 3D axis-aligned bounding box
struct box3 {
	vec3_t min; /// Minimum corner point
	vec3_t max; /// Maximum corner point
};

/// @brief Calculates the center point of the box
ORCA_API vec3_t
BOX3_Center(lpcbox3_t self);

/// @brief 2D rectangle structure
struct rect {
	float x; /// Left edge X coordinate
	float y; /// Top edge Y coordinate
	float width; /// Rectangle width
	float height; /// Rectangle height
};

/// @brief Tests if a point is inside the rectangle
ORCA_API bool_t
RECT_Contains(lpcrect_t self, lpcvec2_t point);

/// @brief Returns a scaled copy of the rectangle
ORCA_API rect_t
RECT_Scale(lpcrect_t self, float scale);

/// @brief Calculates the center point of the rectangle
ORCA_API vec2_t
RECT_Center(lpcrect_t self);

/// @brief Scales rectangle to fit within given dimensions while preserving aspect ratio
ORCA_API rect_t
RECT_Fit(lpcrect_t self, lpcvec2_t big);

/// @brief Quaternion for 3D rotations
struct quat {
	float x; /// X component of quaternion
	float y; /// Y component of quaternion
	float z; /// Z component of quaternion
	float w; /// W component (scalar part) of quaternion
};

/// @brief Creates quaternion from Euler angles
ORCA_API quat_t
QUAT_FromEuler(lpcvec3_t euler, eRotationOrder_t order);

/// @brief Extracts quaternion from rotation matrix
ORCA_API quat_t
QUAT_FromMatrix(lpcmat4_t matrix);

/// @brief Calculates dot product with another quaternion
ORCA_API float
QUAT_DotProduct(lpcquat_t self, lpcquat_t other);

/// @brief Returns the magnitude of the quaternion
ORCA_API float
QUAT_Length(lpcquat_t self);

/// @brief Returns the conjugate of the quaternion
ORCA_API quat_t
QUAT_Unm(lpcquat_t self);

/// @brief Returns a normalized copy of the quaternion
ORCA_API quat_t
QUAT_Normalized(lpcquat_t self);

/// @brief Spherical linear interpolation between quaternions
ORCA_API quat_t
QUAT_Slerp(lpcquat_t self, lpcquat_t q, float t);

/// @brief Squad (spherical cubic) interpolation between quaternions
ORCA_API quat_t
QUAT_Sqlerp(lpcquat_t self, lpcquat_t b, lpcquat_t c, lpcquat_t d, float t);

/// @brief 3x3 transformation matrix
struct mat3 {
	float v[9]; /// Matrix elements in column-major order
};

/// @brief Creates an identity matrix
ORCA_API mat3_t
MAT3_Identity(void);

/// @brief Creates normal transformation matrix from 4x4 matrix
ORCA_API mat3_t
MAT3_Normal(lpcmat4_t matrix);

/// @brief Applies translation to the matrix
ORCA_API void
MAT3_Translate(lpmat3_t self, lpcvec2_t offset);

/// @brief Applies scaling to the matrix
ORCA_API void
MAT3_Scale(lpmat3_t self, lpcvec2_t scale);

/// @brief 4x4 transformation matrix
struct mat4 {
	float v[16]; /// Matrix elements in column-major order
};

/// @brief Creates an identity matrix
ORCA_API mat4_t
MAT4_Identity(void);

/// @brief Applies translation to the matrix
ORCA_API void
MAT4_Translate(lpmat4_t self, lpcvec3_t offset);

/// @brief Applies rotation using Euler angles
ORCA_API void
MAT4_Rotate(lpmat4_t self, lpcvec3_t euler, eRotationOrder_t order);

/// @brief Applies scaling to the matrix
ORCA_API void
MAT4_Scale(lpmat4_t self, lpcvec3_t scale);

/// @brief Multiplies this matrix with another
ORCA_API mat4_t
MAT4_Multiply(lpcmat4_t self, lpcmat4_t other);

/// @brief Creates orthographic projection matrix
ORCA_API mat4_t
MAT4_Ortho(float left, float right, float bottom, float top, float znear, float zfar);

/// @brief Creates perspective projection matrix
ORCA_API mat4_t
MAT4_Perspective(float radians, float aspect, float znear, float zfar);

/// @brief Creates view matrix for camera positioning
ORCA_API mat4_t
MAT4_LookAt(lpcvec3_t eye, lpcvec3_t direction, lpcvec3_t up);

/// @brief Calculates the inverse matrix
ORCA_API mat4_t
MAT4_Inverse(lpcmat4_t self);

/// @brief Returns the transposed matrix
ORCA_API mat4_t
MAT4_Transpose(lpcmat4_t self);

/// @brief Applies quaternion rotation to the matrix
ORCA_API void
MAT4_Rotate4(lpmat4_t self, lpcvec4_t quat);

/// @brief Transforms a 3D point by this matrix
ORCA_API vec3_t
MAT4_MultiplyVector3D(lpcmat4_t self, lpcvec3_t point);

/// @brief Creates matrix from rotation around a specific origin point
ORCA_API mat4_t
MAT4_FromRotationOrigin(lpcquat_t rotation, lpcvec3_t origin);

/// @brief Creates full transformation matrix with custom origin
ORCA_API mat4_t
MAT4_FromRotationTranslationScaleOrigin(lpcquat_t rotation, lpcvec3_t translation, lpcvec3_t scale, lpcvec3_t origin);

/// @brief Creates translation-only matrix
ORCA_API mat4_t
MAT4_FromTranslation(lpcvec3_t translation);

/// @brief Applies quaternion rotation to the matrix
ORCA_API void
MAT4_RotateQuat(lpmat4_t self, lpcquat_t rotation);

/// @brief 1D range bounds
struct bounds {
	float min; /// Minimum value of the range
	float max; /// Maximum value of the range
};

/// @brief 3D plane representation
struct plane3 {
	float a; /// X component of plane normal
	float b; /// Y component of plane normal
	float c; /// Z component of plane normal
	float d; /// Distance from origin along normal
};

/// @brief Normalizes the plane equation
ORCA_API void
plane3_Normalize(lpplane3_t self);

/// @brief Calculates signed distance from point to plane
ORCA_API float
plane3_MultiplyVector3D(lpcplane3_t self, lpcvec3_t point);

/// @brief 3D sphere representation
struct sphere3 {
	vec3_t center; /// Center point of the sphere
	float radius; /// Radius of the sphere
};

/// @brief 3D viewing frustum
struct frustum3 {
	plane3_t left; /// Left clipping plane
	plane3_t right; /// Right clipping plane
	plane3_t bottom; /// Bottom clipping plane
	plane3_t top; /// Top clipping plane
	plane3_t front; /// Near clipping plane
	plane3_t back; /// Far clipping plane
};

/// @brief Extracts frustum planes from projection matrix
ORCA_API frustum3_t
frustum_Calculate(lpcmat4_t matrix);

/// @brief Tests if a point is inside the frustum
ORCA_API bool_t
frustum_ContainsPoint(lpcfrustum3_t self, lpcvec3_t point);

/// @brief Tests if a sphere intersects the frustum
ORCA_API bool_t
frustum_ContainsSphere(lpcfrustum3_t self, lpcsphere3_t sphere);

/// @brief Tests if a transformed bounding box intersects the frustum
ORCA_API bool_t
frustum_ContainsBox(lpcfrustum3_t self, lpcbox3_t box, lpcmat4_t matrix);

/// @brief Tests if an axis-aligned box intersects the frustum
ORCA_API bool_t
frustum_ContainsAABox(lpcfrustum3_t self, lpcbox3_t box);

/// @brief 2D transformation structure
struct transform2 {
	vec2_t translation; /// Translation offset
	float rotation; /// Rotation angle in radians
	vec2_t scale; /// Scale factors for X and Y axes
};

/// @brief Creates identity transformation
ORCA_API transform2_t
transform2_Identity(void);

/// @brief Converts to 4x4 transformation matrix
ORCA_API mat4_t
transform2_ToMatrix3D(lpctransform2_t self, lpcvec2_t pivot);

/// @brief 3D transformation structure
struct transform3 {
	vec3_t translation; /// Translation offset
	vec3_t rotation; /// Euler angles in radians (x=pitch, y=yaw, z=roll)
	vec3_t scale; /// Scale factors for X, Y, and Z axes
};

/// @brief Creates identity transformation
ORCA_API transform3_t
transform3_Identity(void);

/// @brief Converts to 4x4 transformation matrix
ORCA_API mat4_t
transform3_ToMatrix3D(lpctransform3_t self, lpcvec3_t pivot);

/// @brief 3D triangle primitive
struct triangle3 {
	vec3_t a; /// First vertex of the triangle
	vec3_t b; /// Second vertex of the triangle
	vec3_t c; /// Third vertex of the triangle
};

/// @brief Calculates the triangle's surface normal
ORCA_API vec3_t
triangle3_normal(lpctriangle3_t self);

/// @brief 3D line segment
struct line3 {
	vec3_t a; /// Start point of the line segment
	vec3_t b; /// End point of the line segment
};

/// @brief Tests intersection with a sphere
ORCA_API bool_t
line3_intersect_sphere3(lpcline3_t self, lpcsphere3_t sphere, lpvec3_t out);

/// @brief Tests intersection with a plane
ORCA_API bool_t
line3_intersect_plane3(lpcline3_t self, lpcplane3_t plane, lpvec3_t out);

/// @brief Tests intersection with a triangle
ORCA_API bool_t
line3_intersect_triangle(lpcline3_t self, lpctriangle3_t triangle, lpvec3_t out);

/// @brief Tests intersection with a 3D bounding box
ORCA_API bool_t
line3_intersect_box3(lpcline3_t self, lpcbox3_t box, lpvec3_t out);

/// @brief Edge insets structure
struct edges {
	float left; /// Left edge spacing
	float top; /// Top edge spacing
	float right; /// Right edge spacing
	float bottom; /// Bottom edge spacing
};

/// @brief RGBA color representation
struct color {
	float r; /// Red component (0.0 to 1.0)
	float g; /// Green component (0.0 to 1.0)
	float b; /// Blue component (0.0 to 1.0)
	float a; /// Alpha (transparency) component (0.0 = transparent, 1.0 = opaque)
};

/// @brief Linear interpolation between colors
ORCA_API color_t
COLOR_Lerp(lpccolor_t self, lpccolor_t other, float t);

/// @brief Parses color from string representation
ORCA_API color_t
COLOR_Parse(const char* code);

#endif
