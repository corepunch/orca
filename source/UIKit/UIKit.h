// Generated by codegen utility
#ifndef __UIKIT_H__
#define __UIKIT_H__

#include <include/orca.h>

#include <source/UIKit/UIKit_properties.h>

typedef struct BorderRadiusShorthand BorderRadiusShorthand_t, *lpBorderRadiusShorthand_t;
typedef struct BorderRadiusShorthand const cBorderRadiusShorthand_t, *lpcBorderRadiusShorthand_t;
/// @brief Push BorderRadiusShorthand onto Lua stack.
ORCA_API void
luaX_pushBorderRadiusShorthand(lua_State *L, lpcBorderRadiusShorthand_t BorderRadiusShorthand);
/// @brief Check BorderRadiusShorthand form Lua stack at index.
ORCA_API lpBorderRadiusShorthand_t
luaX_checkBorderRadiusShorthand(lua_State *L, int idx);

typedef struct BorderEdgeShorthand BorderEdgeShorthand_t, *lpBorderEdgeShorthand_t;
typedef struct BorderEdgeShorthand const cBorderEdgeShorthand_t, *lpcBorderEdgeShorthand_t;
/// @brief Push BorderEdgeShorthand onto Lua stack.
ORCA_API void
luaX_pushBorderEdgeShorthand(lua_State *L, lpcBorderEdgeShorthand_t BorderEdgeShorthand);
/// @brief Check BorderEdgeShorthand form Lua stack at index.
ORCA_API lpBorderEdgeShorthand_t
luaX_checkBorderEdgeShorthand(lua_State *L, int idx);

typedef struct BorderSideShorthand BorderSideShorthand_t, *lpBorderSideShorthand_t;
typedef struct BorderSideShorthand const cBorderSideShorthand_t, *lpcBorderSideShorthand_t;
/// @brief Push BorderSideShorthand onto Lua stack.
ORCA_API void
luaX_pushBorderSideShorthand(lua_State *L, lpcBorderSideShorthand_t BorderSideShorthand);
/// @brief Check BorderSideShorthand form Lua stack at index.
ORCA_API lpBorderSideShorthand_t
luaX_checkBorderSideShorthand(lua_State *L, int idx);

typedef struct BorderShorthand BorderShorthand_t, *lpBorderShorthand_t;
typedef struct BorderShorthand const cBorderShorthand_t, *lpcBorderShorthand_t;
/// @brief Push BorderShorthand onto Lua stack.
ORCA_API void
luaX_pushBorderShorthand(lua_State *L, lpcBorderShorthand_t BorderShorthand);
/// @brief Check BorderShorthand form Lua stack at index.
ORCA_API lpBorderShorthand_t
luaX_checkBorderShorthand(lua_State *L, int idx);

typedef struct EdgeShorthand EdgeShorthand_t, *lpEdgeShorthand_t;
typedef struct EdgeShorthand const cEdgeShorthand_t, *lpcEdgeShorthand_t;
/// @brief Push EdgeShorthand onto Lua stack.
ORCA_API void
luaX_pushEdgeShorthand(lua_State *L, lpcEdgeShorthand_t EdgeShorthand);
/// @brief Check EdgeShorthand form Lua stack at index.
ORCA_API lpEdgeShorthand_t
luaX_checkEdgeShorthand(lua_State *L, int idx);

typedef struct AlignmentShorthand AlignmentShorthand_t, *lpAlignmentShorthand_t;
typedef struct AlignmentShorthand const cAlignmentShorthand_t, *lpcAlignmentShorthand_t;
/// @brief Push AlignmentShorthand onto Lua stack.
ORCA_API void
luaX_pushAlignmentShorthand(lua_State *L, lpcAlignmentShorthand_t AlignmentShorthand);
/// @brief Check AlignmentShorthand form Lua stack at index.
ORCA_API lpAlignmentShorthand_t
luaX_checkAlignmentShorthand(lua_State *L, int idx);

typedef struct FontShorthand FontShorthand_t, *lpFontShorthand_t;
typedef struct FontShorthand const cFontShorthand_t, *lpcFontShorthand_t;
/// @brief Push FontShorthand onto Lua stack.
ORCA_API void
luaX_pushFontShorthand(lua_State *L, lpcFontShorthand_t FontShorthand);
/// @brief Check FontShorthand form Lua stack at index.
ORCA_API lpFontShorthand_t
luaX_checkFontShorthand(lua_State *L, int idx);

typedef struct BrushShorthand BrushShorthand_t, *lpBrushShorthand_t;
typedef struct BrushShorthand const cBrushShorthand_t, *lpcBrushShorthand_t;
/// @brief Push BrushShorthand onto Lua stack.
ORCA_API void
luaX_pushBrushShorthand(lua_State *L, lpcBrushShorthand_t BrushShorthand);
/// @brief Check BrushShorthand form Lua stack at index.
ORCA_API lpBrushShorthand_t
luaX_checkBrushShorthand(lua_State *L, int idx);

typedef struct ShadowShorthand ShadowShorthand_t, *lpShadowShorthand_t;
typedef struct ShadowShorthand const cShadowShorthand_t, *lpcShadowShorthand_t;
/// @brief Push ShadowShorthand onto Lua stack.
ORCA_API void
luaX_pushShadowShorthand(lua_State *L, lpcShadowShorthand_t ShadowShorthand);
/// @brief Check ShadowShorthand form Lua stack at index.
ORCA_API lpShadowShorthand_t
luaX_checkShadowShorthand(lua_State *L, int idx);

typedef struct RingShorthand RingShorthand_t, *lpRingShorthand_t;
typedef struct RingShorthand const cRingShorthand_t, *lpcRingShorthand_t;
/// @brief Push RingShorthand onto Lua stack.
ORCA_API void
luaX_pushRingShorthand(lua_State *L, lpcRingShorthand_t RingShorthand);
/// @brief Check RingShorthand form Lua stack at index.
ORCA_API lpRingShorthand_t
luaX_checkRingShorthand(lua_State *L, int idx);

typedef struct OverflowShorthand OverflowShorthand_t, *lpOverflowShorthand_t;
typedef struct OverflowShorthand const cOverflowShorthand_t, *lpcOverflowShorthand_t;
/// @brief Push OverflowShorthand onto Lua stack.
ORCA_API void
luaX_pushOverflowShorthand(lua_State *L, lpcOverflowShorthand_t OverflowShorthand);
/// @brief Check OverflowShorthand form Lua stack at index.
ORCA_API lpOverflowShorthand_t
luaX_checkOverflowShorthand(lua_State *L, int idx);

typedef struct UnderlineShorthand UnderlineShorthand_t, *lpUnderlineShorthand_t;
typedef struct UnderlineShorthand const cUnderlineShorthand_t, *lpcUnderlineShorthand_t;
/// @brief Push UnderlineShorthand onto Lua stack.
ORCA_API void
luaX_pushUnderlineShorthand(lua_State *L, lpcUnderlineShorthand_t UnderlineShorthand);
/// @brief Check UnderlineShorthand form Lua stack at index.
ORCA_API lpUnderlineShorthand_t
luaX_checkUnderlineShorthand(lua_State *L, int idx);

typedef struct Thickness Thickness_t, *lpThickness_t;
typedef struct Thickness const cThickness_t, *lpcThickness_t;
/// @brief Push Thickness onto Lua stack.
ORCA_API void
luaX_pushThickness(lua_State *L, lpcThickness_t Thickness);
/// @brief Check Thickness form Lua stack at index.
ORCA_API lpThickness_t
luaX_checkThickness(lua_State *L, int idx);

typedef struct MarginShorthand MarginShorthand_t, *lpMarginShorthand_t;
typedef struct MarginShorthand const cMarginShorthand_t, *lpcMarginShorthand_t;
/// @brief Push MarginShorthand onto Lua stack.
ORCA_API void
luaX_pushMarginShorthand(lua_State *L, lpcMarginShorthand_t MarginShorthand);
/// @brief Check MarginShorthand form Lua stack at index.
ORCA_API lpMarginShorthand_t
luaX_checkMarginShorthand(lua_State *L, int idx);

typedef struct SizeAxisShorthand SizeAxisShorthand_t, *lpSizeAxisShorthand_t;
typedef struct SizeAxisShorthand const cSizeAxisShorthand_t, *lpcSizeAxisShorthand_t;
/// @brief Push SizeAxisShorthand onto Lua stack.
ORCA_API void
luaX_pushSizeAxisShorthand(lua_State *L, lpcSizeAxisShorthand_t SizeAxisShorthand);
/// @brief Check SizeAxisShorthand form Lua stack at index.
ORCA_API lpSizeAxisShorthand_t
luaX_checkSizeAxisShorthand(lua_State *L, int idx);

typedef struct SizeShorthand SizeShorthand_t, *lpSizeShorthand_t;
typedef struct SizeShorthand const cSizeShorthand_t, *lpcSizeShorthand_t;
/// @brief Push SizeShorthand onto Lua stack.
ORCA_API void
luaX_pushSizeShorthand(lua_State *L, lpcSizeShorthand_t SizeShorthand);
/// @brief Check SizeShorthand form Lua stack at index.
ORCA_API lpSizeShorthand_t
luaX_checkSizeShorthand(lua_State *L, int idx);

typedef struct NavigateToPageArguments NavigateToPageArguments_t, *lpNavigateToPageArguments_t;
typedef struct NavigateToPageArguments const cNavigateToPageArguments_t, *lpcNavigateToPageArguments_t;
/// @brief Push NavigateToPageArguments onto Lua stack.
ORCA_API void
luaX_pushNavigateToPageArguments(lua_State *L, lpcNavigateToPageArguments_t NavigateToPageArguments);
/// @brief Check NavigateToPageArguments form Lua stack at index.
ORCA_API lpNavigateToPageArguments_t
luaX_checkNavigateToPageArguments(lua_State *L, int idx);

typedef struct NavigateBackArguments NavigateBackArguments_t, *lpNavigateBackArguments_t;
typedef struct NavigateBackArguments const cNavigateBackArguments_t, *lpcNavigateBackArguments_t;
/// @brief Push NavigateBackArguments onto Lua stack.
ORCA_API void
luaX_pushNavigateBackArguments(lua_State *L, lpcNavigateBackArguments_t NavigateBackArguments);
/// @brief Check NavigateBackArguments form Lua stack at index.
ORCA_API lpNavigateBackArguments_t
luaX_checkNavigateBackArguments(lua_State *L, int idx);

typedef struct DataObject DataObject_t, *lpDataObject_t;
typedef struct DataObject const cDataObject_t, *lpcDataObject_t;
/// @brief Push DataObject onto Lua stack.
ORCA_API void
luaX_pushDataObject(lua_State *L, lpcDataObject_t DataObject);
/// @brief Check DataObject form Lua stack at index.
ORCA_API lpDataObject_t
luaX_checkDataObject(lua_State *L, int idx);

typedef struct AnimationPlayer AnimationPlayer_t, *lpAnimationPlayer_t;
typedef struct AnimationPlayer const cAnimationPlayer_t, *lpcAnimationPlayer_t;
/// @brief Push AnimationPlayer onto Lua stack.
ORCA_API void
luaX_pushAnimationPlayer(lua_State *L, lpcAnimationPlayer_t AnimationPlayer);
/// @brief Check AnimationPlayer form Lua stack at index.
ORCA_API lpAnimationPlayer_t
luaX_checkAnimationPlayer(lua_State *L, int idx);

typedef struct Trigger Trigger_t, *lpTrigger_t;
typedef struct Trigger const cTrigger_t, *lpcTrigger_t;
/// @brief Push Trigger onto Lua stack.
ORCA_API void
luaX_pushTrigger(lua_State *L, lpcTrigger_t Trigger);
/// @brief Check Trigger form Lua stack at index.
ORCA_API lpTrigger_t
luaX_checkTrigger(lua_State *L, int idx);

typedef struct OnPropertyChangedTrigger OnPropertyChangedTrigger_t, *lpOnPropertyChangedTrigger_t;
typedef struct OnPropertyChangedTrigger const cOnPropertyChangedTrigger_t, *lpcOnPropertyChangedTrigger_t;
/// @brief Push OnPropertyChangedTrigger onto Lua stack.
ORCA_API void
luaX_pushOnPropertyChangedTrigger(lua_State *L, lpcOnPropertyChangedTrigger_t OnPropertyChangedTrigger);
/// @brief Check OnPropertyChangedTrigger form Lua stack at index.
ORCA_API lpOnPropertyChangedTrigger_t
luaX_checkOnPropertyChangedTrigger(lua_State *L, int idx);

typedef struct OnAttachedTrigger OnAttachedTrigger_t, *lpOnAttachedTrigger_t;
typedef struct OnAttachedTrigger const cOnAttachedTrigger_t, *lpcOnAttachedTrigger_t;
/// @brief Push OnAttachedTrigger onto Lua stack.
ORCA_API void
luaX_pushOnAttachedTrigger(lua_State *L, lpcOnAttachedTrigger_t OnAttachedTrigger);
/// @brief Check OnAttachedTrigger form Lua stack at index.
ORCA_API lpOnAttachedTrigger_t
luaX_checkOnAttachedTrigger(lua_State *L, int idx);

typedef struct EventTrigger EventTrigger_t, *lpEventTrigger_t;
typedef struct EventTrigger const cEventTrigger_t, *lpcEventTrigger_t;
/// @brief Push EventTrigger onto Lua stack.
ORCA_API void
luaX_pushEventTrigger(lua_State *L, lpcEventTrigger_t EventTrigger);
/// @brief Check EventTrigger form Lua stack at index.
ORCA_API lpEventTrigger_t
luaX_checkEventTrigger(lua_State *L, int idx);

typedef struct Setter Setter_t, *lpSetter_t;
typedef struct Setter const cSetter_t, *lpcSetter_t;
/// @brief Push Setter onto Lua stack.
ORCA_API void
luaX_pushSetter(lua_State *L, lpcSetter_t Setter);
/// @brief Check Setter form Lua stack at index.
ORCA_API lpSetter_t
luaX_checkSetter(lua_State *L, int idx);

typedef struct Handler Handler_t, *lpHandler_t;
typedef struct Handler const cHandler_t, *lpcHandler_t;
/// @brief Push Handler onto Lua stack.
ORCA_API void
luaX_pushHandler(lua_State *L, lpcHandler_t Handler);
/// @brief Check Handler form Lua stack at index.
ORCA_API lpHandler_t
luaX_checkHandler(lua_State *L, int idx);

typedef struct Brush Brush_t, *lpBrush_t;
typedef struct Brush const cBrush_t, *lpcBrush_t;
/// @brief Push Brush onto Lua stack.
ORCA_API void
luaX_pushBrush(lua_State *L, lpcBrush_t Brush);
/// @brief Check Brush form Lua stack at index.
ORCA_API lpBrush_t
luaX_checkBrush(lua_State *L, int idx);

typedef struct ColorBrush ColorBrush_t, *lpColorBrush_t;
typedef struct ColorBrush const cColorBrush_t, *lpcColorBrush_t;
/// @brief Push ColorBrush onto Lua stack.
ORCA_API void
luaX_pushColorBrush(lua_State *L, lpcColorBrush_t ColorBrush);
/// @brief Check ColorBrush form Lua stack at index.
ORCA_API lpColorBrush_t
luaX_checkColorBrush(lua_State *L, int idx);

typedef struct Node Node_t, *lpNode_t;
typedef struct Node const cNode_t, *lpcNode_t;
/// @brief Push Node onto Lua stack.
ORCA_API void
luaX_pushNode(lua_State *L, lpcNode_t Node);
/// @brief Check Node form Lua stack at index.
ORCA_API lpNode_t
luaX_checkNode(lua_State *L, int idx);

typedef struct TextRun TextRun_t, *lpTextRun_t;
typedef struct TextRun const cTextRun_t, *lpcTextRun_t;
/// @brief Push TextRun onto Lua stack.
ORCA_API void
luaX_pushTextRun(lua_State *L, lpcTextRun_t TextRun);
/// @brief Check TextRun form Lua stack at index.
ORCA_API lpTextRun_t
luaX_checkTextRun(lua_State *L, int idx);

typedef struct TextBlockConcept TextBlockConcept_t, *lpTextBlockConcept_t;
typedef struct TextBlockConcept const cTextBlockConcept_t, *lpcTextBlockConcept_t;
/// @brief Push TextBlockConcept onto Lua stack.
ORCA_API void
luaX_pushTextBlockConcept(lua_State *L, lpcTextBlockConcept_t TextBlockConcept);
/// @brief Check TextBlockConcept form Lua stack at index.
ORCA_API lpTextBlockConcept_t
luaX_checkTextBlockConcept(lua_State *L, int idx);

typedef struct Node2D Node2D_t, *lpNode2D_t;
typedef struct Node2D const cNode2D_t, *lpcNode2D_t;
/// @brief Push Node2D onto Lua stack.
ORCA_API void
luaX_pushNode2D(lua_State *L, lpcNode2D_t Node2D);
/// @brief Check Node2D form Lua stack at index.
ORCA_API lpNode2D_t
luaX_checkNode2D(lua_State *L, int idx);

typedef struct PrefabView2D PrefabView2D_t, *lpPrefabView2D_t;
typedef struct PrefabView2D const cPrefabView2D_t, *lpcPrefabView2D_t;
/// @brief Push PrefabView2D onto Lua stack.
ORCA_API void
luaX_pushPrefabView2D(lua_State *L, lpcPrefabView2D_t PrefabView2D);
/// @brief Check PrefabView2D form Lua stack at index.
ORCA_API lpPrefabView2D_t
luaX_checkPrefabView2D(lua_State *L, int idx);

typedef struct TextBlock TextBlock_t, *lpTextBlock_t;
typedef struct TextBlock const cTextBlock_t, *lpcTextBlock_t;
/// @brief Push TextBlock onto Lua stack.
ORCA_API void
luaX_pushTextBlock(lua_State *L, lpcTextBlock_t TextBlock);
/// @brief Check TextBlock form Lua stack at index.
ORCA_API lpTextBlock_t
luaX_checkTextBlock(lua_State *L, int idx);

typedef struct Input Input_t, *lpInput_t;
typedef struct Input const cInput_t, *lpcInput_t;
/// @brief Push Input onto Lua stack.
ORCA_API void
luaX_pushInput(lua_State *L, lpcInput_t Input);
/// @brief Check Input form Lua stack at index.
ORCA_API lpInput_t
luaX_checkInput(lua_State *L, int idx);

typedef struct Button Button_t, *lpButton_t;
typedef struct Button const cButton_t, *lpcButton_t;
/// @brief Push Button onto Lua stack.
ORCA_API void
luaX_pushButton(lua_State *L, lpcButton_t Button);
/// @brief Check Button form Lua stack at index.
ORCA_API lpButton_t
luaX_checkButton(lua_State *L, int idx);

typedef struct Label Label_t, *lpLabel_t;
typedef struct Label const cLabel_t, *lpcLabel_t;
/// @brief Push Label onto Lua stack.
ORCA_API void
luaX_pushLabel(lua_State *L, lpcLabel_t Label);
/// @brief Check Label form Lua stack at index.
ORCA_API lpLabel_t
luaX_checkLabel(lua_State *L, int idx);

typedef struct StackView StackView_t, *lpStackView_t;
typedef struct StackView const cStackView_t, *lpcStackView_t;
/// @brief Push StackView onto Lua stack.
ORCA_API void
luaX_pushStackView(lua_State *L, lpcStackView_t StackView);
/// @brief Check StackView form Lua stack at index.
ORCA_API lpStackView_t
luaX_checkStackView(lua_State *L, int idx);

typedef struct Form Form_t, *lpForm_t;
typedef struct Form const cForm_t, *lpcForm_t;
/// @brief Push Form onto Lua stack.
ORCA_API void
luaX_pushForm(lua_State *L, lpcForm_t Form);
/// @brief Check Form form Lua stack at index.
ORCA_API lpForm_t
luaX_checkForm(lua_State *L, int idx);

typedef struct CollectionView CollectionView_t, *lpCollectionView_t;
typedef struct CollectionView const cCollectionView_t, *lpcCollectionView_t;
/// @brief Push CollectionView onto Lua stack.
ORCA_API void
luaX_pushCollectionView(lua_State *L, lpcCollectionView_t CollectionView);
/// @brief Check CollectionView form Lua stack at index.
ORCA_API lpCollectionView_t
luaX_checkCollectionView(lua_State *L, int idx);

typedef struct Control Control_t, *lpControl_t;
typedef struct Control const cControl_t, *lpcControl_t;
/// @brief Push Control onto Lua stack.
ORCA_API void
luaX_pushControl(lua_State *L, lpcControl_t Control);
/// @brief Check Control form Lua stack at index.
ORCA_API lpControl_t
luaX_checkControl(lua_State *L, int idx);

typedef struct Screen Screen_t, *lpScreen_t;
typedef struct Screen const cScreen_t, *lpcScreen_t;
/// @brief Push Screen onto Lua stack.
ORCA_API void
luaX_pushScreen(lua_State *L, lpcScreen_t Screen);
/// @brief Check Screen form Lua stack at index.
ORCA_API lpScreen_t
luaX_checkScreen(lua_State *L, int idx);

typedef struct Cinematic Cinematic_t, *lpCinematic_t;
typedef struct Cinematic const cCinematic_t, *lpcCinematic_t;
/// @brief Push Cinematic onto Lua stack.
ORCA_API void
luaX_pushCinematic(lua_State *L, lpcCinematic_t Cinematic);
/// @brief Check Cinematic form Lua stack at index.
ORCA_API lpCinematic_t
luaX_checkCinematic(lua_State *L, int idx);

typedef struct Grid Grid_t, *lpGrid_t;
typedef struct Grid const cGrid_t, *lpcGrid_t;
/// @brief Push Grid onto Lua stack.
ORCA_API void
luaX_pushGrid(lua_State *L, lpcGrid_t Grid);
/// @brief Check Grid form Lua stack at index.
ORCA_API lpGrid_t
luaX_checkGrid(lua_State *L, int idx);

typedef struct ImageView ImageView_t, *lpImageView_t;
typedef struct ImageView const cImageView_t, *lpcImageView_t;
/// @brief Push ImageView onto Lua stack.
ORCA_API void
luaX_pushImageView(lua_State *L, lpcImageView_t ImageView);
/// @brief Check ImageView form Lua stack at index.
ORCA_API lpImageView_t
luaX_checkImageView(lua_State *L, int idx);

typedef struct NinePatchImage NinePatchImage_t, *lpNinePatchImage_t;
typedef struct NinePatchImage const cNinePatchImage_t, *lpcNinePatchImage_t;
/// @brief Push NinePatchImage onto Lua stack.
ORCA_API void
luaX_pushNinePatchImage(lua_State *L, lpcNinePatchImage_t NinePatchImage);
/// @brief Check NinePatchImage form Lua stack at index.
ORCA_API lpNinePatchImage_t
luaX_checkNinePatchImage(lua_State *L, int idx);

typedef struct TerminalView TerminalView_t, *lpTerminalView_t;
typedef struct TerminalView const cTerminalView_t, *lpcTerminalView_t;
/// @brief Push TerminalView onto Lua stack.
ORCA_API void
luaX_pushTerminalView(lua_State *L, lpcTerminalView_t TerminalView);
/// @brief Check TerminalView form Lua stack at index.
ORCA_API lpTerminalView_t
luaX_checkTerminalView(lua_State *L, int idx);

typedef struct Page Page_t, *lpPage_t;
typedef struct Page const cPage_t, *lpcPage_t;
/// @brief Push Page onto Lua stack.
ORCA_API void
luaX_pushPage(lua_State *L, lpcPage_t Page);
/// @brief Check Page form Lua stack at index.
ORCA_API lpPage_t
luaX_checkPage(lua_State *L, int idx);

typedef struct PageHost PageHost_t, *lpPageHost_t;
typedef struct PageHost const cPageHost_t, *lpcPageHost_t;
/// @brief Push PageHost onto Lua stack.
ORCA_API void
luaX_pushPageHost(lua_State *L, lpcPageHost_t PageHost);
/// @brief Check PageHost form Lua stack at index.
ORCA_API lpPageHost_t
luaX_checkPageHost(lua_State *L, int idx);

typedef struct Style Style_t, *lpStyle_t;
typedef struct Style const cStyle_t, *lpcStyle_t;
/// @brief Push Style onto Lua stack.
ORCA_API void
luaX_pushStyle(lua_State *L, lpcStyle_t Style);
/// @brief Check Style form Lua stack at index.
ORCA_API lpStyle_t
luaX_checkStyle(lua_State *L, int idx);

#include <source/renderer/api/renderer.h>
#include <include/renderer.h>
#include <source/UIKit/uidef.h>
typedef struct Object Object_t, *lpObject_t;
typedef struct Object const cObject_t, *lpcObject_t;
typedef struct ViewText ViewText_t, *lpViewText_t;
typedef struct ViewText const cViewText_t, *lpcViewText_t;
typedef struct text_info text_info_t, *lptext_info_t;
typedef struct text_info const ctext_info_t, *lpctext_info_t;
#define kEventGetSize 0x80d9e0ee
typedef void* GetSizeEventPtr;

#define kEventSubmit 0x4078e545
typedef void* SubmitEventPtr;

typedef enum Direction {
	kDirectionHorizontal, /// Left-to-right horizontal layout
	kDirectionVertical, /// Top-to-bottom vertical layout
	kDirectionDepth, /// Front-to-back depth layout (3D)
} eDirection_t;

typedef enum Box3Field {
	kBox3FieldX, /// X-coordinate of the box origin
	kBox3FieldY, /// Y-coordinate of the box origin
	kBox3FieldZ, /// Z-coordinate of the box origin
	kBox3FieldWidth, /// Width of the box along the X axis
	kBox3FieldHeight, /// Height of the box along the Y axis
	kBox3FieldDepth, /// Depth of the box along the Z axis
} eBox3Field_t;

typedef enum TextHorizontalAlignment {
	kTextHorizontalAlignmentLeft, /// Align text to the left edge
	kTextHorizontalAlignmentCenter, /// Center text horizontally
	kTextHorizontalAlignmentRight, /// Align text to the right edge
} eTextHorizontalAlignment_t;

typedef enum TextVerticalAlignment {
	kTextVerticalAlignmentTop, /// Align text to the top
	kTextVerticalAlignmentCenter, /// Center text vertically
	kTextVerticalAlignmentBottom, /// Align text to the bottom
	kTextVerticalAlignmentBaseline, /// Align to text baseline
} eTextVerticalAlignment_t;

typedef enum HorizontalAlignment {
	kHorizontalAlignmentLeft, /// Align to left edge of container
	kHorizontalAlignmentCenter, /// Center within container
	kHorizontalAlignmentRight, /// Align to right edge of container
	kHorizontalAlignmentStretch, /// Stretch to fill container width
} eHorizontalAlignment_t;

typedef enum VerticalAlignment {
	kVerticalAlignmentTop, /// Align to top edge of container
	kVerticalAlignmentCenter, /// Center within container
	kVerticalAlignmentBottom, /// Align to bottom edge of container
	kVerticalAlignmentStretch, /// Stretch to fill container height
} eVerticalAlignment_t;

typedef enum AlignItems {
	kAlignItemsStart, /// Align to start of cross axis
	kAlignItemsCenter, /// Center on cross axis
	kAlignItemsEnd, /// Align to end of cross axis
	kAlignItemsStretch, /// Stretch across cross axis
	kAlignItemsBaseline, /// Align to text baseline
} eAlignItems_t;

typedef enum DepthAlignment {
	kDepthAlignmentNear, /// Align to near clipping plane
	kDepthAlignmentCenter, /// Center in depth
	kDepthAlignmentFar, /// Align to far clipping plane
	kDepthAlignmentStretch, /// Stretch across depth
} eDepthAlignment_t;

typedef enum Overflow {
	kOverflowVisible, /// Content overflows container bounds
	kOverflowHidden, /// Clip overflowing content
	kOverflowClip, /// Hard clipping without scrollbars
	kOverflowScroll, /// Show scrollbars for overflow
	kOverflowAuto, /// Automatic scrollbar behavior
} eOverflow_t;

typedef enum ForegroundHint {
	kForegroundHintNone, /// No special foreground treatment
	kForegroundHintTranslucent, /// Hint for translucent foreground
	kForegroundHintOpaque, /// Hint for opaque foreground optimization
} eForegroundHint_t;

typedef enum JustifyContent {
	kJustifyContentStart, /// Pack items to start
	kJustifyContentEnd, /// Pack items to end
	kJustifyContentCenter, /// Center items
	kJustifyContentSpaceBetween, /// Distribute with space between
	kJustifyContentSpaceAround, /// Distribute with space around
	kJustifyContentSpaceEvenly, /// Distribute with even spacing
} eJustifyContent_t;

typedef enum FontWeight {
	kFontWeightNormal, /// Standard font weight
	kFontWeightBold, /// Bold font weight
} eFontWeight_t;

typedef enum FontStyle {
	kFontStyleNormal, /// Regular font style
	kFontStyleItalic, /// Italic font style
} eFontStyle_t;

typedef enum BorderStyle {
	kBorderStyleNone, /// No border
	kBorderStyleHidden, /// Hidden border (takes space but invisible)
	kBorderStyleDotted, /// Dotted border pattern
	kBorderStyleDashed, /// Dashed border pattern
	kBorderStyleSolid, /// Solid continuous border
	kBorderStyleDouble, /// Double line border
	kBorderStyleGroove, /// 3D grooved border effect
	kBorderStyleRidge, /// 3D ridged border effect
	kBorderStyleInset, /// 3D inset border effect
	kBorderStyleOutset, /// 3D outset border effect
} eBorderStyle_t;

typedef enum PlaybackMode {
	kPlaybackModeNormal, /// Standard forward playback
	kPlaybackModeReverse, /// Reverse playback from end to start
	kPlaybackModePingpong, /// Alternating forward/reverse playback
} ePlaybackMode_t;

typedef enum ButtonType {
	kButtonTypeNormal, /// Standard interactive button
	kButtonTypeSubmit, /// Form submission button with special handling
} eButtonType_t;

typedef enum InputType {
	kInputTypeText, /// Single or multi-line text input 
	kInputTypePassword, /// Masked password input for security 
	kInputTypeNumber, /// Numeric input with validation 
	kInputTypeCheckbox, /// Boolean checkbox control 
	kInputTypeRadio, /// Radio button for exclusive selection 
} eInputType_t;

typedef enum Sizing {
	kSizingPlusMargin, /// Include margins in size calculation
	kSizingSizeOnly, /// Return only the base size
	kSizingMinusPadding, /// Subtract padding from size
} eSizing_t;

/// @brief Corner rounding configuration for rectangular elements
struct BorderRadiusShorthand {
	float TopLeftRadius; /// Top-left corner radius
	float TopRightRadius; /// Top-right corner radius
	float BottomRightRadius; /// Bottom-right corner radius
	float BottomLeftRadius; /// Bottom-left corner radius
};

/// @brief Complete border definition for one edge
struct BorderEdgeShorthand {
	float Width; /// {0} border thickness in pixels
	eBorderStyle_t Style; /// Visual style of the {0} border
	color_t Color; /// {0} border color
};

/// @brief Border definitions for both sides of an axis
struct BorderSideShorthand {
	BorderEdgeShorthand_t Left; /// Leading edge border (left/top/near)
	BorderEdgeShorthand_t Right; /// Trailing edge border (right/bottom/far)
};

/// @brief Complete border definition for rectangular element
struct BorderShorthand {
	BorderRadiusShorthand_t Radius; /// Border radius definition per corner
	BorderSideShorthand_t Axis[3]; /// Border definition per axis
};

/// @brief Spacing values for opposite edges of an axis
struct EdgeShorthand {
	float Left; /// Leading edge value (left for horizontal, top for vertical, near for depth)
	float Right; /// Trailing edge value (right for horizontal, bottom for vertical, far for depth)
};

/// @brief Axis-specific alignment parameters.
struct AlignmentShorthand {
	int32_t Axis[3]; /// Alignment of the element within its parent (similar to HorizontalAlignment/VerticalAlignment in XAML).
};

/// @brief Complete font specification including weight, style, size, and family
struct FontShorthand {
	eFontWeight_t Weight; /// Font weight (normal or bold)
	eFontStyle_t Style; /// Font style (normal or italic)
	float Size; /// Font size in points
	lpFontFamily_t Family; /// Font family reference
};

/// @brief Represents a generic brush used for filling UI elements.
struct BrushShorthand {
	color_t Color; /// Solid color fill. Conceptually similar to a CSS `color` or `background-color`.
	lpTexture_t Image; /// Texture/image fill. Conceptually similar to a CSS `background-image`.
	lpMaterial_t Material; /// Custom material or shader fill. Advanced fill using shader/material settings for effects beyond simple color or image.
};

/// @brief Drop shadow effect configuration
struct ShadowShorthand {
	vec2_t Offset; /// Shadow offset from element (x, y)
	float BlurRadius; /// Blur amount for shadow softness
	float SpreadRadius; /// Shadow expansion beyond element bounds
	color_t Color; /// Shadow color and opacity
};

/// @brief Decorative ring/outline effect around elements
struct RingShorthand {
	float Offset; /// Distance from element edge to ring
	float Width; /// Ring thickness in pixels
	color_t Color; /// Ring color and opacity
};

/// @brief Per-axis overflow behavior configuration
struct OverflowShorthand {
	eOverflow_t x; /// Horizontal overflow handling
	eOverflow_t y; /// Vertical overflow handling
};

/// @brief Defines shorthand underline properties (offset, width, and color).
struct UnderlineShorthand {
	float Offset; /// Vertical offset of the underline from the baseline.
	float Width; /// Line thickness of the underline.
	color_t Color; /// Color of the underline.
};

/// @brief Uniform thickness specification for all four edges
struct Thickness {
	float Top; /// Top edge thickness
	float Right; /// Right edge thickness
	float Bottom; /// Bottom edge thickness
	float Left; /// Left edge thickness
};

/// @brief External spacing configuration for rectangular elements
struct MarginShorthand {
	EdgeShorthand_t Axis[3]; /// External spacing per axis
};

/// @brief Complete sizing definition for one axis
struct SizeAxisShorthand {
	float Requested; /// Requested {0} size in pixels
	float Min; /// Minimum allowable {0} size along
	float Actual; /// Actual (calculated) {0} size after layout resolution
	float Scroll; /// Total {0} size required for scrolling content
};

/// @brief Sizing configuration of elements (e.g., Width, Height, Depth)
struct SizeShorthand {
	SizeAxisShorthand_t Axis[3]; /// A number value per axis
};

typedef struct DataObject DataObject, *DataObjectPtr;
typedef struct DataObject const *DataObjectCPtr;
/// @brief Base class for data-holding objects within the framework
struct DataObject {
};

typedef struct AnimationPlayer AnimationPlayer, *AnimationPlayerPtr;
typedef struct AnimationPlayer const *AnimationPlayerCPtr;
/// @brief Controls playback of animations within the UI engine.
struct AnimationPlayer {
	bool_t AutoplayEnabled; /// Enables or disables automatic playback on initialization.
	float DurationScale; /// Scales the playback speed of the animation. A value greater than 1.0 speeds up playback, while values between 0.0 and 1.0 slow it down.
	ePlaybackMode_t PlaybackMode; /// Defines how the animation should be played.
	bool_t RelativePlayback; /// When true, playback is relative to the current state rather than starting from an absolute base state.
	int32_t RepeatCount; ///  Number of times the animation should repeat. Use -1 (or another sentinel value, depending on implementation) to indicate infinite looping.
	bool_t RestoreOriginalValuesAfterPlayback; /// Restores the original property values after the animation ends.
	lpTimeline_t Timeline; /// Reference to the animation timeline that defines keyframes and transitions.
};

typedef struct Trigger Trigger, *TriggerPtr;
typedef struct Trigger const *TriggerCPtr;
/// @brief Base class for event-driven actions within the UI system
struct Trigger {
	fixedString_t Property; /// Target property name to monitor or modify 
	int32_t Value; /// Associated value for the trigger condition 
};

typedef struct OnPropertyChangedTrigger OnPropertyChangedTrigger, *OnPropertyChangedTriggerPtr;
typedef struct OnPropertyChangedTrigger const *OnPropertyChangedTriggerCPtr;
/// @brief Responds to property value changes on specified nodes
struct OnPropertyChangedTrigger {
	fixedString_t SourceNode; /// Name or identifier of the node to monitor 
	fixedString_t Property; /// Property name to watch for changes 
};

typedef struct OnAttachedTrigger OnAttachedTrigger, *OnAttachedTriggerPtr;
typedef struct OnAttachedTrigger const *OnAttachedTriggerCPtr;
/// @brief Triggers when an element is attached to the visual tree
struct OnAttachedTrigger {
};

typedef struct EventTrigger EventTrigger, *EventTriggerPtr;
typedef struct EventTrigger const *EventTriggerCPtr;
/// @brief Responds to routed UI events (mouse, keyboard, etc.)
struct EventTrigger {
	fixedString_t RoutedEvent; /// Name of the routed event to handle (e.g., "MouseDown", "KeyPress") 
};

typedef struct Setter Setter, *SetterPtr;
typedef struct Setter const *SetterCPtr;
/// @brief Applies property values when triggered by specified conditions
struct Setter {
	lpTrigger_t Trigger; /// Triggering condition or state image 
	fixedString_t Property; /// Target property name to set 
	fixedString_t Value; /// Value to apply to the property 
};

typedef struct Handler Handler, *HandlerPtr;
typedef struct Handler const *HandlerCPtr;
/// @brief Executes custom functions when triggered by specified conditions
struct Handler {
	lpTrigger_t Trigger; /// Triggering condition or state image 
	lpObject_t Target; /// Target object to call function on 
	fixedString_t Function; /// Function name to execute on target 
};

typedef struct Brush Brush, *BrushPtr;
typedef struct Brush const *BrushCPtr;
/// @brief Base class for all brush types used in rendering.
struct Brush {
};

typedef struct ColorBrush ColorBrush, *ColorBrushPtr;
typedef struct ColorBrush const *ColorBrushCPtr;
/// @brief Brush that fills an area with a solid color.
struct ColorBrush {
	color_t Color; /// The color value used to fill the target area.
};

typedef struct Node Node, *NodePtr;
typedef struct Node const *NodeCPtr;
/// @brief Base class for all UI engine nodes.
struct Node {
	SizeShorthand_t Size; /// Sizing configuration of this element
	MarginShorthand_t Margin; /// External spacing around the element
	MarginShorthand_t Padding; /// Internal spacing between element border and content
	BorderShorthand_t Border; /// Border definition along each axis
	AlignmentShorthand_t Alignment; /// Alignment definition for each axis.
	bool_t Visible; /// Whether this node is visible in the scene.
	bool_t QuickHide; /// If true, node is quickly hidden without triggering full visibility transitions.
	float VisibleAmountInParent; /// Specifies how much of the node is visible within its parent container. Value in range [0.0, 1.0].
	float Opacity; /// Opacity of the node, range [0.0 = transparent, 1.0 = fully opaque].
	objectTags_t Tags; /// Tag collection for categorizing or querying nodes.
	lpDataObject_t DataContext; /// Data context (used for data binding, similar to XAML's DataContext).
};

typedef struct TextRun TextRun, *TextRunPtr;
typedef struct TextRun const *TextRunCPtr;
/// @brief Shared concept for text rendering in 2D and 3D nodes.
struct TextRun {
	fixedString_t Text; /// The short text string displayed in the block, limited to 64 bytes. If you need more space consider using `TextResourceID`.
	FontShorthand_t Font; /// Font definition used for text rendering. Contains typeface, size, and style information.
	UnderlineShorthand_t Underline; /// Underline style applied to the text.
	float LetterSpacing; /// Additional spacing applied between letters.
	float LineHeight; /// Line height multiplier for multi-line text layout.
	float CharacterSpacing; /// Extra spacing between characters, beyond kerning.
	float FixedCharacterWidth; /// Forces a fixed width per character (monospace effect).
	bool_t RemoveSideBearingsProperty; /// Removes side bearings (spacing) defined by the font.
	float TextureWidth; /// The width of the rendered text texture. Unlike ActualWidth, this does not include padding.
	float TextureHeight; /// The height of the rendered text texture. Unlike ActualHeight, this does not include padding.
	uiLabelSize_t _size; /// Internal text size metrics.
	text_info_t _textinfo; /// Internal text information structure.
	lpFontShorthand_t _font; /// Reference to the font shorthand configuration.
};

typedef struct TextBlockConcept TextBlockConcept, *TextBlockConceptPtr;
typedef struct TextBlockConcept const *TextBlockConceptCPtr;
/// @brief Shared concept for text rendering in 2D and 3D nodes.
struct TextBlockConcept {
	fixedString_t TextResourceID; /// Resource identifier for localized text lookup.
	fixedString_t TextResourceConfiguration; /// Configuration key used when resolving text resources.
	fixedString_t PlaceholderText; /// Placeholder text displayed when no main text is set.
	fixedString_t TextOverflow; /// Defines how overflowing text should be handled (clip, ellipsis, etc.).
	BrushShorthand_t Placeholder; /// Brush definition for rendering placeholder text.
	bool_t UseFullFontHeight; /// When true, uses the font's full height for layout calculations.
	bool_t ConstrainContentHeight; /// Constrains the content height to the text's bounding box.
	bool_t WordWrap; /// Enables automatic word wrapping of the text.
	eTextHorizontalAlignment_t TextHorizontalAlignment; /// Horizontal alignment of the text within its bounds.
	eTextVerticalAlignment_t TextVerticalAlignment; /// Vertical alignment of the text within its bounds.
	uiLabelSteps_t _steps; /// Internal step-based rendering parameters.
	lpNode_t _node; /// Reference to the owning node using this concept.
	lpViewText_t _text; /// Internal view representation of the text.
};

typedef struct Node2D Node2D, *Node2DPtr;
typedef struct Node2D const *Node2DCPtr;
/// @brief Primary class for 2D UI elements with comprehensive rendering capabilities
struct Node2D {
	transform2_t LayoutTransform; /// Transformation applied during layout calculations. Similar to WPF `LayoutTransform`. Affects size and positioning but does not influence local rendering.
	transform2_t RenderTransform; /// Transformation applied at render time. Similar to WPF `RenderTransform`. Affects how the element is drawn (rotation, scale, skew, etc.) without altering layout.
	vec2_t RenderTransformOrigin; /// The origin point for applying RenderTransform. Equivalent to WPF `RenderTransformOrigin`. Defines pivot relative to the element.
	vec2_t ContentOffset; /// Pixel offset applied to the element's content. Can be used for subpixel positioning or scrolling adjustments.
	mat4_t Matrix; /// Final transformation matrix applied to the node. Computed result of layout, render, and parent transforms.
	lpTexture_t RenderTarget; /// Optional render target for offscreen drawing. When set, the node is rendered into this texture/image instead of directly on screen.
	BrushShorthand_t Background; /// Background brush for the element. Equivalent to WPF `Background`. Supports solid color, image, or material.
	BrushShorthand_t Foreground; /// Foreground brush for the element. Equivalent to WPF `Foreground`. Typically used for text or shape fills.
	ShadowShorthand_t BoxShadow; /// Shadow applied to the element's box. Equivalent to CSS `box-shadow` or WPF `DropShadowEffect`.
	OverflowShorthand_t Overflow; /// Defines overflow behavior for child content. Equivalent to CSS `overflow`. Controls clipping and scroll behavior.
	RingShorthand_t Ring; /// Decorative ring effect applied around the element. Similar in purpose to CSS `outline` or focus ring indicators.
	lpMaterial_t CompositionBrush; /// Custom composition brush for advanced rendering. Equivalent to UWP `CompositionBrush`. Can be used for effects or visuals beyond standard brushes.
	vec2_t CompositionDesignSize; /// Virtual design size when using composition rendering. Defines the expected size for the composition surface.
	bool_t SizeToContent; /// Whether the element resizes itself to fit its content. Equivalent to WPF `SizeToContent`.
	bool_t OffscreenRendering; /// Enables rendering to an offscreen surface before compositing. Useful for caching effects or complex visuals.
	bool_t ForceComposition; /// Forces use of the composition system even when not required. Equivalent to enabling composition layers for debugging or effects.
	bool_t CacheResult; /// Enables caching of rendering results. Similar to WPF `CacheMode`. Reduces redraw cost at the expense of memory.
	bool_t SnapToPixel; /// Snaps rendering to device pixels. Equivalent to WPF `SnapsToDevicePixels`. Improves text sharpness.
	bool_t ClipChildren; /// Controls whether children are clipped to the bounds of the element. Equivalent to WPF `ClipToBounds`.
	bool_t ContentStretch; /// Determines if content stretches to fill available space. Equivalent to WPF `Stretch` when applied to child content.
	bool_t Hovered; /// Indicates if the element is currently hovered by pointer/mouse. Equivalent to WPF `IsMouseOver`.
	bool_t IgnoreHitTest; /// Marks object as ignored during hit testing (mouse interaction).
	eForegroundHint_t ForegroundHint; /// Hint for how foreground should be rendered. May be used for accessibility, high-contrast, or text rendering optimizations.
	lpNode_t _node; /// Internal node reference 
	lpObject_t _object; /// Internal object reference 
	int32_t _userdata; /// User-defined data storage 
	rect_t _rect; /// Internal rectangle bounds 
	actualPos_t _actual_pos; /// Internal computed position 
	float _opacity; /// Internal opacity value 
	int32_t _bbox_flags; /// Internal bounding box flags 
};

/// @brief Check if a specific frame property is set on a Node2D
ORCA_API bool_t
Node2D_IsFrameSet(lpNode2D_t self, eBox3Field_t field);

/// @brief Set a frame property value on a Node2D
ORCA_API void
Node2D_SetFrame(lpNode2D_t self, eBox3Field_t field, float value);

/// @brief Get a frame property value from a Node2D
ORCA_API float
Node2D_GetFrame(lpNode2D_t self, eBox3Field_t field);

/// @brief Perform the measure phase of layout for a Node2D
ORCA_API void
Node2D_Measure(lpNode2D_t self, eDirection_t direction, float availableSize, bool_t forceRemeasure);

/// @brief Perform the arrange phase of layout for a Node2D
ORCA_API void
Node2D_Arrange(lpNode2D_t self, bounds_t bounds, eDirection_t direction);

/// @brief Get the layout bounds of a Node2D along a specific axis
ORCA_API bounds_t
Node2D_GetBounds(lpNode2D_t self, eDirection_t axis);

/// @brief Get the 2D rectangle bounds of a Node2D
ORCA_API rect_t
Node2D_GetRect(lpNode2D_t self);

/// @brief Get the background rendering rectangle for a Node2D
ORCA_API rect_t
Node2D_GetBackgroundRect(lpNode2D_t self);

/// @brief Utility function for calculating node dimensions with different sizing modes
ORCA_API float
Node2D_GetSize(lpNode2D_t self, eDirection_t axis, eSizing_t sizing);

typedef struct PrefabView2D PrefabView2D, *PrefabView2DPtr;
typedef struct PrefabView2D const *PrefabView2DCPtr;
/// @brief Container for loading and displaying prefabricated UI components
struct PrefabView2D {
	fixedString_t SCA; /// Scene archive identifier or path 
	fixedString_t Prefab; /// Prefab resource name within the archive 
	int32_t _loadedSCA; /// Hashed value of currently loaded SCA
	int32_t _loadedPrefab; /// Hashed value of loaded prefab instance 
};

typedef struct TextBlock TextBlock, *TextBlockPtr;
typedef struct TextBlock const *TextBlockCPtr;
/// @brief Concrete implementation of text display combining Node2D and TextBlockConcept
struct TextBlock {
	lpNode2D_t _node2D; /// Internal reference to the underlying Node2D instance 
};

typedef struct Input Input, *InputPtr;
typedef struct Input const *InputCPtr;
/// @brief Interactive text input control with multiple input modes
struct Input {
	fixedString_t Name; /// Input identifier for forms and data binding 
	eInputType_t Type; /// Input behavior type (text, password, etc.) 
	int32_t Cursor; /// Current text cursor position 
	bool_t Multiline; /// Allow multiple lines of text input 
	bool_t Checked; /// Checked state for checkbox/radio types 
	lpTexture_t _checkmark; /// Internal checkmark image for checkbox rendering
};

typedef struct Button Button, *ButtonPtr;
typedef struct Button const *ButtonCPtr;
/// @brief Interactive button control for user actions
struct Button {
	eButtonType_t Type; /// Button behavior type (normal or submit) 
};

typedef struct Label Label, *LabelPtr;
typedef struct Label const *LabelCPtr;
/// @brief Text label with optional association to form controls
struct Label {
	fixedString_t For; /// Identifier of associated form control 
};

typedef struct StackView StackView, *StackViewPtr;
typedef struct StackView const *StackViewCPtr;
/// @brief Linear layout container arranging children in a single direction
struct StackView {
	bool_t Reversed; /// Reverse the order of child elements 
	eDirection_t Direction; /// Layout direction (horizontal or vertical) 
	eAlignItems_t AlignItems; /// Cross-axis alignment of children 
	eJustifyContent_t JustifyContent; /// Main-axis distribution of children 
	float Spacing; /// Space between adjacent children 
};

typedef struct Form Form, *FormPtr;
typedef struct Form const *FormCPtr;
/// @brief Specialized stack view for form input collection and submission
struct Form {
};

typedef struct CollectionView CollectionView, *CollectionViewPtr;
typedef struct CollectionView const *CollectionViewCPtr;
/// @brief Container for dynamic collections of data-driven items
struct CollectionView {
	eDirection_t Direction; /// Primary layout direction for items 
	float Spacing; /// Space between collection items 
};

typedef struct Control Control, *ControlPtr;
typedef struct Control const *ControlCPtr;
/// @brief Base class for interactive UI controls with state management
struct Control {
	bool_t Pressed; /// Currently being pressed by user input 
	bool_t Disabled; /// Interaction disabled, typically grayed out 
	bool_t Hovered; /// Mouse pointer is over the control 
	bool_t Focused; /// Control has keyboard focus 
	bool_t Value; /// Generic boolean value for toggle controls 
	float Scale; /// Visual scale factor for size adjustments 
};

typedef enum ResizeMode {
	kResizeModeNoResize, /// The window size is fixed. The user cannot resize or maximize the window.
	kResizeModeCanMinimize, /// The user can minimize the window, but resizing and maximizing are disabled.
	kResizeModeCanResize, /// The user can freely resize the window and maximize it.
	kResizeModeCanResizeWithGrip, /// The user can resize and maximize the window. A resize grip is displayed in the lower-right corner if the platform supports it.
} eResizeMode_t;

typedef struct Screen Screen, *ScreenPtr;
typedef struct Screen const *ScreenCPtr;
/// @brief Top-level container representing a display surface or window
struct Screen {
	color_t ClearColor; /// Background clear color for the screen 
	eResizeMode_t ResizeMode; /// Specifies how the window can be resized or displayed
	lpTexture_t _rt; /// Internal render target for the screen
	uint32_t _size; /// Currently set size (to resize window when changed).
	bool_t _initialized; /// Used to set initial window size
};

typedef struct Cinematic Cinematic, *CinematicPtr;
typedef struct Cinematic const *CinematicCPtr;
/// @brief Video or animation playback view for media content
struct Cinematic {
	fixedString_t FileName; /// Path to media file for playback 
	float FrameRate; /// Playback frame rate (frames per second) 
	float NumFrames; /// Total number of frames in the media 
	float FadeOut; /// Fade-out duration in seconds 
	bool_t _playing; /// Internal playback state flag 
	longTime_t _starttime; /// Internal playback start timestamp 
};

typedef struct Grid Grid, *GridPtr;
typedef struct Grid const *GridCPtr;
/// @brief Grid-based layout container with configurable rows and columns
struct Grid {
	fixedString_t Columns; /// Column definition string (e.g., "1fr 2fr 100px") 
	fixedString_t Rows; /// Row definition string (e.g., "auto 1fr auto") 
	eDirection_t Direction; /// Primary fill direction for auto-placement 
	float Spacing; /// Space between grid cells 
	float CellWidth; /// Default width for auto-sized cells 
	float CellHeight; /// Default height for auto-sized cells 
	uiGridViewBuffer_t _buffer; /// Internal buffer for grid calculations 
};

typedef enum Stretch {
	kStretchNone, /// Do not scale the content; display at its native size
	kStretchFill, /// Scale content to fill both width and height, ignoring aspect ratio
	kStretchUniform, /// Scale content uniformly to fit within the area, preserving aspect ratio
	kStretchUniformToFill, /// Scale content uniformly to fill the area, preserving aspect ratio but cropping if necessary
} eStretch_t;

typedef struct ImageView ImageView, *ImageViewPtr;
typedef struct ImageView const *ImageViewCPtr;
/// @brief Displays image content with advanced rendering and scaling options
struct ImageView {
	fixedString_t Src; /// Image source path or resource identifier 
	lpTexture_t Image; /// Direct reference to loaded image 
	vec4_t Edges; /// Edge inset values for nine-patch rendering 
	vec4_t Insets; /// Content inset values for image positioning 
	vec4_t Viewbox; /// Viewport rectangle for image cropping/scaling 
	eStretch_t Stretch; /// Determines how the image is scaled to fill its allocated layout space
	int32_t _loadedImage; /// Hashed value of loaded image resource 
};

typedef struct NinePatchImage NinePatchImage, *NinePatchImagePtr;
typedef struct NinePatchImage const *NinePatchImageCPtr;
/// @brief Specialized image view for nine-patch (stretchable) images
struct NinePatchImage {
	float StretchTypeTop; /// Top edge stretch behavior factor 
	float StretchTypeBottom; /// Bottom edge stretch behavior factor 
	float StretchTypeLeft; /// Left edge stretch behavior factor 
	float StretchTypeRight; /// Right edge stretch behavior factor 
	float StretchTypeCenter; /// Center region stretch behavior factor 
	lpTexture_t ImageTopLeft; /// Top-left corner image (non-stretchable) 
	lpTexture_t ImageTop; /// Top edge image (horizontally stretchable) 
	lpTexture_t ImageTopRight; /// Top-right corner image (non-stretchable) 
	lpTexture_t ImageLeft; /// Left edge image (vertically stretchable) 
	lpTexture_t ImageCenter; /// Center region image (stretchable in both directions) 
	lpTexture_t ImageRight; /// Right edge image (vertically stretchable) 
	lpTexture_t ImageBottomLeft; /// Bottom-left corner image (non-stretchable) 
	lpTexture_t ImageBottom; /// Bottom edge image (horizontally stretchable) 
	lpTexture_t ImageBottomRight; /// Bottom-right corner image (non-stretchable) 
};

typedef struct TerminalView TerminalView, *TerminalViewPtr;
typedef struct TerminalView const *TerminalViewCPtr;
/// @brief Displays a fixed-size text grid using a monospace layout
struct TerminalView {
	int32_t BufferWidth; /// Buffer width
	int32_t BufferHeight; /// Buffer height
	int32_t Cursor; /// Cursor position
	int32_t SelectedIndex; /// Selected item index
	bool_t DropShadow; /// Draw shadow underneath this view
	int32_t* _buffer; /// Buffer used for characters
	vec2_t _scroll; /// Scroll position
	int32_t _contentHeight; /// Current page length
};

typedef enum TransitionType {
	kTransitionTypeNone, /// No transition
	kTransitionTypeSlide, /// Sliding transition
	kTransitionTypeFade, /// Fading transition
} eTransitionType_t;

/// @brief Event triggered to navigate to a different page within a PageHost.
struct NavigateToPageArguments {
	fixedString_t URL; /// The URL of the page to navigate to.
	eTransitionType_t TransitionType; /// The type of transition animation to use during navigation.
};

/// @brief Event triggered to navigate back to the previous page in the navigation history.
struct NavigateBackArguments {
	eTransitionType_t TransitionType; /// The type of transition animation to use during navigation.
};

#define kEventNavigateToPage 0x6475c790
typedef struct NavigateToPageArguments* NavigateToPageEventPtr;

#define kEventNavigateBack 0x36bc88b5
typedef struct NavigateBackArguments* NavigateBackEventPtr;

typedef struct Page Page, *PagePtr;
typedef struct Page const *PageCPtr;
/// @brief Represents a single page within a document or UI container.
struct Page {
	fixedString_t Title; /// The title of the page.
	fixedString_t Path; /// The URL path of the page, like "/about".
	float Transition; /// The transition progress of the page.
	lpNode_t _node; /// Pointer to Node for quick referencing
};

typedef struct PageHost PageHost, *PageHostPtr;
typedef struct PageHost const *PageHostCPtr;
/// @brief Container that manages multiple pages and navigation between them.
struct PageHost {
	lpPage_t ActivePage; /// The currently active page.
	lpPage_t _historyStack[32]; /// Navigation history stack.
	int32_t _historySize; /// Number of entries in the navigation history stack.
};

typedef enum StyleType {
	kStyleTypeGeneric, /// Base style applied to all components of the specified target type. Serves as a default visual definition.
	kStyleTypeNamed, /// Style associated with a specific theme or visual skin. Used to switch appearance dynamically based on active theme.
} eStyleType_t;

typedef struct Style Style, *StylePtr;
typedef struct Style const *StyleCPtr;
/// @brief Defines a reusable set of property values and visual configurations for a target component type.
struct Style {
	fixedString_t TargetType; /// Specifies the component type this style targets. Only components of the given type or its derived types will use the style.
	eStyleType_t Type; /// Defines the classification of this style, such as Generic, Theme, Override, Local, or Template, determining its scope and application behavior.
};

#endif
