"""Lua export C file writer plugin."""

import os

from . import Plugin
from .state import g_enums, g_structs, g_components, g_resources
from .utils import (
	lp, lpc, _e,
	atomic_types,
	camel_case,
	component_get_parents,
	enum_component_properties,
	export_check_var,
	export_get_name,
	export_index_name,
	export_newindex_name,
	export_push_var,
	hash,
	header_get_arg_type,
	header_get_method_arg,
	header_get_method_name,
	header_get_method_this,
	lpobject_t,
	property_name,
)


class ExportWriter(Plugin):
	"""Generates a Lua-binding C export file (_export.c) from module XML."""

	def __init__(self):
		self.file = None

	def open(self, xml, root):
		base, _ = os.path.splitext(xml)
		self.root, self.name, self.namespace = root, root.get('name'), root.get('namespace')
		self.file = open(base + "_export.c", "w")
		self.w(f"// Generated by codegen utility")
		self.w(f"#include <include/api.h>")
		self.w(f"#include <{base[base.index('source/'):] + '.h'}>")

		if root.find('component') is not None:
			self.w(f"#define DECL(SHORT, LONG, CLASS, NAME, FIELD, TYPE,...) {{ \\")
			self.w(f"\t.id=&(struct ID){{.Name=#CLASS\".\"NAME,.Identifier=SHORT}}, \\")
			self.w(f"\t.FullIdentifier=LONG, \\")
			self.w(f"\t.Offset=offsetof(struct CLASS, FIELD), \\")
			self.w(f"\t.DataSize=sizeof(((struct CLASS *)NULL)->FIELD), \\")
			self.w(f"\t.DataType=TYPE, ##__VA_ARGS__ }}")

		self.w(f"")

	def close(self):
		self.w(f"ORCA_API int luaopen_{self.namespace}_{self.name}(lua_State *L) {{")
		self.w(f"\tluaL_newlib(L, ((luaL_Reg[]) {{")
		for fn in self.root.findall('function'):
			self.w(f"\t\t{{ \"{camel_case(fn.get('name'))}\", {export_get_name(self.root, fn)} }},")
		self.w(f"\t\t{{ NULL, NULL }}")
		self.w(f"\t}}));")
		if self.root.get('on-luaopen'):
			self.w(f"\tvoid {self.root.get('on-luaopen')}(lua_State *L);")
			self.w(f"\t{self.root.get('on-luaopen')}(L);")
		for struct in self.root.findall('struct') + self.root.findall('interface'):
			str_name = struct.get('name')
			self.w(f"\t// {str_name}")
			self.w(f"\tluaopen_{self.namespace}_{str_name}(L);")
			self.w(f"\tlua_setfield(L, -2, \"{struct.get('export', str_name)}\");")
		for component in self.root.findall('component'):
			cmp_name = component.get('name')
			self.w(f"\t// {cmp_name}")
			self.w(f"\tlua_pushclass(L, &_{cmp_name});")
			self.w(f"\tlua_setfield(L, -2, \"{cmp_name}\");")
		for _ in self.root.findall('shutdown'):
			self.w(f"\tAPI_MODULE_SHUTDOWN(L, f_{self.name}_gc);")
		self.w(f"\treturn 1;\n}}")

	def w(self, text):
		self.file.write(text)
		self.file.write("\n")

	def on_shutdown(self, _, shutdown):
		fn = shutdown.get('name')
		self.w(
			f"static int f_{self.name}_gc(lua_State *L) {{\n"
			f"\tvoid {fn}(void);\n\t{fn}();\n\treturn 0;\n}}"
		)

	def on_enums(self, _, enums):
		ename = enums.get('name')
		values = ['"%s"' % e.get('name').lower() for e in enums.findall('enum')] + ["NULL"]
		self.w(f"static const char *_{ename}[] = {{{','.join(values)}}};")
		self.w(f"{_e(ename)} luaX_check{ename}(lua_State *L, int idx) {{")
		self.w(f"\treturn luaL_checkoption(L, idx, NULL, _{ename});")
		self.w(f"}}")
		self.w(f"void luaX_push{ename}(lua_State *L, {_e(ename)} value) {{")
		self.w(f"\tassert(value >= 0 && value < {len(enums.findall('enum'))});")
		self.w(f"\tlua_pushstring(L, _{ename}[value]);")
		self.w(f"}}")

	def on_resource(self, _, resource):
		if resource.get('no-lua'):
			return
		name = resource.get('type')
		self.w(f"void luaX_push{name}(lua_State *L, {lpc(name)} {name}) {{")
		self.w(f"\tlua_pushlightuserdata(L, ({lp(name)}){name});\n}}")
		self.w(f"{lp(name)} luaX_check{name}(lua_State *L, int idx) {{")
		self.w(f"\treturn lua_touserdata(L, idx);\n}}")

	def on_function(self, node, method):
		args = []
		idx = 1
		if method.get('private'):
			return
		if method.get("lua"):
			args.append("L")
		self.w(f"static int {export_get_name(node, method)}(lua_State *L) {{")
		if method.tag == "method" and method.get('static') is None:
			self.w(f"\t{header_get_method_this(node, method)} = luaX_check{node.get('name')}(L, 1);")
			args.append("self")
			idx = 2
		for i, arg in enumerate(method.findall('arg')):
			arg_type = arg.get('type')
			self.w(f"\t{export_check_var(header_get_method_arg(arg), arg_type, i + idx)};")
			args.append(arg.get('name'))
		call = f"{header_get_method_name(node, method)}({', '.join(args)})"
		returns = method.find('returns')
		if returns is None:
			self.w(f"\t{call};\n\treturn 0;")
		elif returns.get('type') == 'nresults':
			self.w(f"\treturn {call};")
		else:
			ret = header_get_arg_type(returns)
			self.w(f"\t{ret} output = {call};\n\t{export_push_var(returns, 'output')};\n\treturn 1;")
		self.w(f"}}")

	def on_interface(self, root, interface):
		self.on_struct(root, interface)

	def on_struct(self, root, struct):
		is_struct = struct.tag == 'struct'
		name = struct.get('name')
		if is_struct:
			self.w(f"void luaX_push{name}(lua_State *L, {lpc(name)} data) {{")
			self.w(f"\t{lp(name)} self = lua_newuserdata(L, sizeof(struct {name}));")
			self.w(f"\tluaL_setmetatable(L, \"{name}\");")
			self.w(f"\tmemcpy(self, data, sizeof(struct {name}));")
			self.w(f"}}")
		if not struct.get("no-check"):
			self.w(f"{lp(name)} luaX_check{name}(lua_State *L, int idx) {{")
			self.w(f"\treturn luaL_checkudata(L, idx, \"{name}\");")
			self.w(f"}}")
		else:
			self.w(f"{lp(name)} luaX_check{name}(lua_State *L, int idx);")
		if is_struct:
			self.w(f"static int f_new_{name}(lua_State *L) {{")
			self.w(f"\t{lp(name)} self = lua_newuserdata(L, sizeof(struct {name}));")
			self.w(f"\tluaL_setmetatable(L, \"{name}\");")
			self.w(f"\tmemset(self, 0, sizeof(struct {name}));")
			for i, arg in enumerate(struct.findall('field')):
				arg_type = arg.get('type')
				if arg.get('array'):
					continue
				if arg_type not in atomic_types:
					continue
				a = f"self->{arg.get('name')}"
				self.w(f"\t{export_check_var(a, arg_type, i + 1)};")
			self.w(f"\t// if (lua_istable(L, 1)) {{")
			self.w(f"\t// }}")
			self.w(f"\treturn 1;\n}}")
			self.w(f"static int f_{name}___call(lua_State *L) {{")
			self.w(f"\tlua_remove(L, 1); // remove {name} from stack")
			self.w(f"\treturn f_new_{name}(L);")
			self.w(f"}}")
		elif struct.find('init') is not None:
			self.w(f"int f_new_{name}(lua_State *L);")
		# write methods
		for method in struct.findall('method'):
			self.on_function(struct, method)
		# write __index function
		self.w(f"int {export_index_name(struct)}(lua_State *L) {{")
		if is_struct:
			self.w(f"\tswitch(fnv1a32(luaL_checkstring(L, 2))) {{")
			for field in struct.findall('field'):
				if field.get('array') or field.get('private'):
					continue
				field_name = field.get('name')
				self.w(f"\tcase {hash(field_name)}: // {field_name}")
				self.w(f"\t\t{export_push_var(field, f'luaX_check{name}(L, 1)->{field_name}')};")
				self.w(f"\t\treturn 1;")
		else:
			self.w(f"\tswitch(fnv1a32(luaL_checkstring(L, 2))) {{")
		for method in struct.findall('method'):
			method_name = method.get('export') or method.get('name')
			if method_name.startswith("__") or method.get('static') or method.get('private'):
				continue
			self.w(f"\tcase {hash(camel_case(method_name))}: // {camel_case(method_name)}")
			self.w(f"\t\tlua_pushcfunction(L, {export_get_name(struct, method)});")
			self.w(f"\t\treturn 1;")
		if is_struct:
			self.w(f"\t}}\n\treturn luaL_error(L, \"Unknown field in {name}: %s\", luaL_checkstring(L, 2));\n}}")
		else:
			self.w(f"\t}}\n\treturn 0;\n}}")
		if is_struct:
			# write __newindex function
			self.w(f"int {export_newindex_name(struct)}(lua_State *L) {{")
			self.w(f"\tswitch(fnv1a32(luaL_checkstring(L, 2))) {{")
			for field in struct.findall('field'):
				if field.get('array'):
					continue
				field_name, field_type = field.get('name'), field.get('type')
				access = "*"
				if field_type in atomic_types: access = ""
				if field_type in g_enums:      access = ""
				if field_type in g_resources:  access = ""
				if field_type in g_components: access = ""
				self.w(f"\tcase {hash(field_name)}: // {field_name}")
				self.w(f"\t\t{export_check_var(f'luaX_check{name}(L, 1)->{field_name}', field_type, 3, access)};")
				self.w(f"\t\treturn 0;")
			self.w(f"\t}}\n\treturn luaL_error(L, \"Unknown field in {name}: %s\", luaL_checkstring(L, 2));\n}}")
		# write lua_open
		self.w(f"int luaopen_{root.get('namespace')}_{name}(lua_State *L) {{")
		self.w(f"\tluaL_newmetatable(L, \"{name}\");")
		self.w(f"\tluaL_setfuncs(L, ((luaL_Reg[]) {{")
		if is_struct or struct.find('init') is not None:
			self.w(f"\t\t{{ \"new\", f_new_{name} }},")
		if is_struct:
			self.w(f"\t\t{{ \"__newindex\", {export_newindex_name(struct)} }},")
		self.w(f"\t\t{{ \"__index\", {export_index_name(struct)} }},")
		for method in struct.findall('method'):
			method_name = method.get('export', method.get('name'))
			if not method_name.startswith("__") and not method.get('static'):
				continue
			self.w(f"\t\t{{ \"{camel_case(method_name)}\", {export_get_name(struct, method)} }},")
		self.w(f"\t\t{{ NULL, NULL }},")
		self.w(f"\t}}), 0);\n")
		if is_struct:
			self.w(f"\tlua_newtable(L);")
			self.w(f"\tlua_pushcfunction(L, f_{name}___call);")
			self.w(f"\tlua_setfield(L, -2, \"__call\");")
			self.w(f"\tlua_setmetatable(L, -2);\n")
		self.w(f"\treturn 1;\n}}")

	def write_property(self, property, component, path):
		cname = component.get('name')
		if property.tag == 'shorthand':
			pname, userdata = property.get('name'), property.get('userdata')
			self.w(
				f"\t/* {cname}.{pname} */ DECL({hash(pname)}, {hash(cname + '.' + pname)},\n"
				f"\t{cname}, \"{pname}\", {path}, kDataTypeEdges, .TypeString=\"{userdata}\"),"
			)
		else:
			name = property_name(path)
			sname = property_name(path)
			ptype = property.get('type')
			struct = g_structs.get(ptype)
			typedata = f"kDataType{ptype[:1].upper() + ptype[1:]}"
			if struct is not None:
				export_as = struct.get('export')
				nfields = 0
				def count(p, _, c): nonlocal nfields; nfields += 1
				enum_component_properties(struct, count)
				typedata = (
					f"kDataType{export_as}" if export_as
					else f"kDataTypeGroup, .TypeString=\"{ptype}\", .NumComponents={nfields}"
				)
			elif ptype in g_enums or sname in g_enums:
				enum = g_enums.get(ptype) or g_enums.get(sname)
				values = [e.get('name') for e in enum.findall('enum')]
				ptype = enum.get('name')
				typedata = f"kDataTypeEnum, .TypeString=\"{','.join(values)}\""
			elif ptype in g_components:
				typedata = f"kDataTypeObject, .TypeString=\"{ptype}\""
			self.w(
				f"\t/* {cname}.{sname} */ DECL({hash(sname)}, {hash(cname + '.' + sname)},\n"
				f"\t{cname}, \"{sname}\", {path}, {typedata}),"
			)

	def on_component(self, root, component):
		cname = component.get('name')
		for handles in component.findall('handles'):
			event = handles.get('event')
			self.w(f"LRESULT {cname}_{event}({lpobject_t}, {lp(cname)}, wParam_t, {event}EventPtr);")
		self.w(f"static struct PropertyDesc const {cname}Properties[k{cname}NumProperties] = {{")

		for shorthand in component.findall("shorthand"):
			pname, physical, userdata = (
				shorthand.get('name'), shorthand.get('physical'), shorthand.get('userdata')
			)
			self.w(
				f"\t/* {cname}.{cname} */ DECL({hash(pname)}, {hash(cname + '.' + pname)},\n"
				f"\t{cname}, \"{pname}\", {physical}, T_EDGES, .TypeString=\"{userdata}\"),"
			)

		enum_component_properties(component, self.write_property)
		self.w(f"}};")

		if bool(component.findall("property[@default]")):
			self.w(f"static struct {cname} {cname}Defaults = {{")
			for property in component.findall("property[@default]"):
				pname, ptype, pdefault = (
					property.get('name'), property.get('type'), property.get('default')
				)
				if ptype in g_enums and not pdefault.lstrip('-').isdigit():
					self.w(f"\t.{pname} = k{ptype}{pdefault},")
				elif ptype in g_structs:
					self.w(f"\t.{pname} = (struct {ptype}) {{ {', '.join(pdefault.split())} }},")
				elif ptype == 'bool':
					self.w(f"\t.{pname} = {pdefault.upper()},")
				elif ptype == 'fixed':
					self.w(f"\t.{pname} = \"{pdefault}\",")
				else:
					self.w(f"\t.{pname} = {pdefault},")
			self.w(f"}};")
		elif bool(component.findall("property")):
			self.w(f"static struct {cname} {cname}Defaults = {{0}};")
		else:
			self.w(f"static struct {cname} {cname}Defaults = {{}};")

		self.w(
			f"LRESULT {cname}Proc({lpobject_t} object, void* cmp, "
			f"uint32_t message, wParam_t wparm, lParam_t lparm) {{"
		)
		self.w(f"\tswitch (message) {{")
		for handles in component.findall('handles'):
			hname = handles.get('event')
			self.w(f"\t\tcase {hash(hname)}: // {hname}")
			self.w(f"\t\t\treturn {cname}_{hname}(object, cmp, wparm, lparm);")
		self.w(f"}}\n\treturn FALSE;\n}}")

		self.w(f"void luaX_push{cname}(lua_State *L, {lpc(cname)} {cname}) {{")
		self.w(f"\tluaX_pushObject(L, CMP_GetObject({cname}));\n}}")
		self.w(f"{lp(cname)} luaX_check{cname}(lua_State *L, int idx) {{")
		self.w(f"\treturn Get{cname}(luaX_checkObject(L, idx));\n}}")

		parents = component_get_parents(component)
		for p in parents:
			self.w(f"extern struct ClassDesc _{p};")
		parents_str = ", ".join([f"&_{p}" for p in parents] + ["NULL"])
		content = component.get('parent', cname)
		if component.get('name').endswith('Library'):
			content = component.get('name').replace('Library', '')
		self.w(f"ORCA_API struct ClassDesc _{cname} = {{")
		self.w(f"\t.ClassName = \"{cname}\",")
		self.w(f"\t.DefaultName = \"{component.get('default', cname)}\",")
		self.w(f"\t.ContentType = \"{component.get('content', content)}\",")
		self.w(f"\t.Xmlns = \"{component.findtext('xmlns')}\",")
		self.w(f"\t.ParentClasses = {{{parents_str}}},")
		self.w(f"\t.ClassID = ID_{cname},")
		self.w(f"\t.ClassSize = sizeof(struct {cname}),")
		self.w(f"\t.Properties = {cname}Properties,")
		self.w(f"\t.ObjProc = {cname}Proc,")
		self.w(f"\t.Defaults = &{cname}Defaults,")
		self.w(f"\t.NumProperties = k{cname}NumProperties,\n}};")
