"""Lua export C file writer plugin."""

import os
import string

from . import Plugin, utils, Workspace

_T = {
	'shutdown': string.Template(
		"static int f_${module_name}_gc(lua_State *L) {\n"
		"\tvoid ${fn}(void);\n"
		"\t${fn}();\n"
		"\treturn 0;\n"
		"}\n"
	),
	'enums': string.Template(
		"static const char *_${ename}[] = {${values}};\n"
		"${ename_t} luaX_check${ename}(lua_State *L, int idx) {\n"
		"\treturn luaL_checkoption(L, idx, NULL, _${ename});\n"
		"}\n"
		"void luaX_push${ename}(lua_State *L, ${ename_t} value) {\n"
		"\tassert(value >= 0 && value < ${count});\n"
		"\tlua_pushstring(L, _${ename}[value]);\n"
		"}\n"
	),
	'resource': string.Template(
		"void luaX_push${name}(lua_State *L, ${lpcname} ${name}) {\n"
		"\tlua_pushlightuserdata(L, (${lpname})${name});\n"
		"}\n"
		"${lpname} luaX_check${name}(lua_State *L, int idx) {\n"
		"\treturn lua_touserdata(L, idx);\n"
		"}\n"
	),
	'struct_push': string.Template(
		"void luaX_push${name}(lua_State *L, ${lpcname} data) {\n"
		"\t${lpname} self = lua_newuserdata(L, sizeof(struct ${name}));\n"
		"\tluaL_setmetatable(L, \"${name}\");\n"
		"\tmemcpy(self, data, sizeof(struct ${name}));\n"
		"}\n"
	),
	'struct_check': string.Template(
		"${lpname} luaX_check${name}(lua_State *L, int idx) {\n"
		"\treturn luaL_checkudata(L, idx, \"${name}\");\n"
		"}\n"
	),
	'struct_new': string.Template(
		"static int f_new_${name}(lua_State *L) {\n"
		"\t${lpname} self = lua_newuserdata(L, sizeof(struct ${name}));\n"
		"\tluaL_setmetatable(L, \"${name}\");\n"
		"\tmemset(self, 0, sizeof(struct ${name}));\n"
		"${init_block}"
		"\treturn 1;\n"
		"}\n"
		"static int f_${name}___call(lua_State *L) {\n"
		"\tlua_remove(L, 1); // remove ${name} from stack\n"
		"\treturn f_new_${name}(L);\n"
		"}\n"
	),
	'component_lua': string.Template(
		"void luaX_push${cname}(lua_State *L, ${lpcname} ${cname}) {\n"
		"\tluaX_pushObject(L, CMP_GetObject(${cname}));\n"
		"}\n"
		"${lpname} luaX_check${cname}(lua_State *L, int idx) {\n"
		"\treturn Get${cname}(luaX_checkObject(L, idx));\n"
		"}\n"
	),
	'class_desc': string.Template(
		"ORCA_API struct ClassDesc _${cname} = {\n"
		"\t.ClassName = \"${cname}\",\n"
		"\t.DefaultName = \"${default_name}\",\n"
		"\t.ContentType = \"${content_type}\",\n"
		"\t.Xmlns = \"${xmlns}\",\n"
		"\t.ParentClasses = {${parents_str}},\n"
		"\t.ClassID = ID_${cname},\n"
		"\t.ClassSize = sizeof(struct ${cname}),\n"
		"\t.Properties = ${cname}Properties,\n"
		"\t.ObjProc = ${cname}Proc,\n"
		"\t.Defaults = &${cname}Defaults,\n"
		"\t.NumProperties = k${cname}NumProperties,\n"
		"};\n"
	),
}


class ExportWriter(Plugin):
	"""Generates a Lua-binding C export file (_export.c) from module XML."""

	def __init__(self):
		self.file = None

	def open(self, xml, root):
		base, _ = os.path.splitext(xml)
		self.root, self.name, self.namespace = root, root.get('name'), root.get('namespace')
		self.file = open(base + "_export.c", "w")
		self.w(f"// Generated by codegen utility")
		self.w(f"#include <include/api.h>")
		self.w(f"#include <{base[base.index('source/'):] + '.h'}>")

		if root.find('component') is not None:
			self.w(f"#define DECL(SHORT, LONG, CLASS, NAME, FIELD, TYPE,...) {{ \\")
			self.w(f"\t.id=&(struct ID){{.Name=#CLASS\".\"NAME,.Identifier=SHORT}}, \\")
			self.w(f"\t.FullIdentifier=LONG, \\")
			self.w(f"\t.Offset=offsetof(struct CLASS, FIELD), \\")
			self.w(f"\t.DataSize=sizeof(((struct CLASS *)NULL)->FIELD), \\")
			self.w(f"\t.DataType=TYPE, ##__VA_ARGS__ }}")

		self.w(f"")

	def close(self):
		self.w(f"ORCA_API int luaopen_{self.namespace}_{self.name}(lua_State *L) {{")
		self.w(f"\tluaL_newlib(L, ((luaL_Reg[]) {{")
		for fn in self.root.findall('function'):
			self.w(f"\t\t{{ \"{utils.camel_case(fn.get('name'))}\", {utils.export_get_name(self.root, fn)} }},")
		self.w(f"\t\t{{ NULL, NULL }}")
		self.w(f"\t}}));")
		if self.root.get('on-luaopen'):
			self.w(f"\tvoid {self.root.get('on-luaopen')}(lua_State *L);")
			self.w(f"\t{self.root.get('on-luaopen')}(L);")
		for struct in self.root.findall('struct') + self.root.findall('interface'):
			str_name = struct.get('name')
			self.w(f"\t// {str_name}")
			self.w(f"\tluaopen_{self.namespace}_{str_name}(L);")
			self.w(f"\tlua_setfield(L, -2, \"{struct.get('export', str_name)}\");")
		for component in self.root.findall('component'):
			cmp_name = component.get('name')
			self.w(f"\t// {cmp_name}")
			self.w(f"\tlua_pushclass(L, &_{cmp_name});")
			self.w(f"\tlua_setfield(L, -2, \"{cmp_name}\");")
		for _ in self.root.findall('shutdown'):
			self.w(f"\tAPI_MODULE_SHUTDOWN(L, f_{self.name}_gc);")
		self.w(f"\treturn 1;\n}}")

	def w(self, text):
		self.file.write(text)
		self.file.write("\n")

	def wt(self, text):
		"""Write a pre-rendered template block (already contains newlines)."""
		self.file.write(text)
		if not text.endswith('\n'):
			self.file.write('\n')

	def on_shutdown(self, _, shutdown):
		fn = shutdown.get('name')
		self.wt(_T['shutdown'].substitute(module_name=self.name, fn=fn))

	def on_enums(self, _, enums):
		ename = enums.get('name')
		values = ['"%s"' % e.get('name').lower() for e in enums.findall('enum')] + ["NULL"]
		self.wt(_T['enums'].substitute(
			ename=ename,
			ename_t=utils._e(ename),
			values=','.join(values),
			count=len(enums.findall('enum')),
		))

	def on_resource(self, _, resource):
		if resource.get('no-lua'):
			return
		name = resource.get('type')
		self.wt(_T['resource'].substitute(
			name=name,
			lpcname=utils.lpc(name),
			lpname=utils.lp(name),
		))

	def on_function(self, node, method):
		args = []
		idx = 1
		if method.get('private'):
			return
		if method.get("lua"):
			args.append("L")
		self.w(f"static int {utils.export_get_name(node, method)}(lua_State *L) {{")
		if method.tag == "method" and method.get('static') is None:
			self.w(f"\t{utils.header_get_method_this(node, method)} = luaX_check{node.get('name')}(L, 1);")
			args.append("self")
			idx = 2
		for i, arg in enumerate(method.findall('arg')):
			arg_type = arg.get('type')
			self.w(f"\t{utils.export_check_var(utils.header_get_method_arg(arg), arg_type, i + idx)};")
			args.append(arg.get('name'))
		call = f"{utils.header_get_method_name(node, method)}({', '.join(args)})"
		returns = method.find('returns')
		if returns is None:
			self.w(f"\t{call};\n\treturn 0;")
		elif returns.get('type') == 'nresults':
			self.w(f"\treturn {call};")
		else:
			ret = utils.header_get_arg_type(returns)
			self.w(f"\t{ret} output = {call};\n\t{utils.export_push_var(returns, 'output')};\n\treturn 1;")
		self.w(f"}}")

	def on_interface(self, root, interface):
		self.on_struct(root, interface)

	def on_struct(self, root, struct):
		is_struct = struct.tag == 'struct'
		name = struct.get('name')
		lpname, lpcname = utils.lp(name), utils.lpc(name)
		if is_struct:
			self.wt(_T['struct_push'].substitute(name=name, lpname=lpname, lpcname=lpcname))
		if not struct.get("no-check"):
			self.wt(_T['struct_check'].substitute(name=name, lpname=lpname))
		else:
			self.w(f"{lpname} luaX_check{name}(lua_State *L, int idx);")
		if is_struct:
			atomic_fields = [
				(i, f) for i, f in enumerate(struct.findall('field'))
				if not f.get('array') and f.get('type') in utils.atomic_types
			]
			if atomic_fields:
				table_inits = ''
				field_inits = ''
				for i, arg in atomic_fields:
					field_name = arg.get('name')
					arg_type = arg.get('type')
					table_inits += f'\t\tlua_getfield(L, 1, "{field_name}");\n'
					if arg_type == 'fixed':
						table_inits += f'\t\tstrncpy(self->{field_name}, luaL_optstring(L, -1, ""), sizeof(self->{field_name}));\n'
					else:
						check_fn = utils.atomic_types[arg_type][0]
						to_fn = check_fn.replace('luaL_check', 'lua_to')
						table_inits += f'\t\tself->{field_name} = {to_fn}(L, -1);\n'
					table_inits += f'\t\tlua_pop(L, 1);\n'
					field_inits += '\t\t' + utils.export_check_var(f"self->{field_name}", arg_type, i + 1) + ';\n'
				init_block = f"\tif (lua_istable(L, 1)) {{\n{table_inits}\t}} else {{\n{field_inits}\t}}\n"
			else:
				init_block = ""
			self.wt(_T['struct_new'].substitute(name=name, lpname=lpname, init_block=init_block))
		elif struct.find('init') is not None:
			self.w(f"int f_new_{name}(lua_State *L);")
		# write methods
		for method in struct.findall('method'):
			self.on_function(struct, method)
		# write __index function
		self.w(f"int {utils.export_index_name(struct)}(lua_State *L) {{")
		if is_struct:
			self.w(f"\tswitch(fnv1a32(luaL_checkstring(L, 2))) {{")
			for field in struct.findall('field'):
				if field.get('array') or field.get('private'):
					continue
				field_name = field.get('name')
				self.w(f"\tcase {utils.hash(field_name)}: // {field_name}")
				self.w(f"\t\t{utils.export_push_var(field, f'luaX_check{name}(L, 1)->{field_name}')};")
				self.w(f"\t\treturn 1;")
		else:
			self.w(f"\tswitch(fnv1a32(luaL_checkstring(L, 2))) {{")
		for method in struct.findall('method'):
			method_name = method.get('export') or method.get('name')
			if method_name.startswith("__") or method.get('static') or method.get('private'):
				continue
			self.w(f"\tcase {utils.hash(utils.camel_case(method_name))}: // {utils.camel_case(method_name)}")
			self.w(f"\t\tlua_pushcfunction(L, {utils.export_get_name(struct, method)});")
			self.w(f"\t\treturn 1;")
		if is_struct:
			self.w(f"\t}}\n\treturn luaL_error(L, \"Unknown field in {name}: %s\", luaL_checkstring(L, 2));\n}}")
		else:
			self.w(f"\t}}\n\treturn 0;\n}}")
		if is_struct:
			# write __newindex function
			self.w(f"int {utils.export_newindex_name(struct)}(lua_State *L) {{")
			self.w(f"\tswitch(fnv1a32(luaL_checkstring(L, 2))) {{")
			for field in struct.findall('field'):
				if field.get('array'):
					continue
				field_name, field_type = field.get('name'), field.get('type')
				access = "*"
				if field_type in utils.atomic_types:   access = ""
				if field_type in Workspace.enums:      access = ""
				if field_type in Workspace.resources:  access = ""
				if field_type in Workspace.components: access = ""
				self.w(f"\tcase {utils.hash(field_name)}: // {field_name}")
				self.w(f"\t\t{utils.export_check_var(f'luaX_check{name}(L, 1)->{field_name}', field_type, 3, access)};")
				self.w(f"\t\treturn 0;")
			self.w(f"\t}}\n\treturn luaL_error(L, \"Unknown field in {name}: %s\", luaL_checkstring(L, 2));\n}}")
		# write lua_open
		self.w(f"int luaopen_{root.get('namespace')}_{name}(lua_State *L) {{")
		self.w(f"\tluaL_newmetatable(L, \"{name}\");")
		self.w(f"\tluaL_setfuncs(L, ((luaL_Reg[]) {{")
		if is_struct or struct.find('init') is not None:
			self.w(f"\t\t{{ \"new\", f_new_{name} }},")
		if is_struct:
			self.w(f"\t\t{{ \"__newindex\", {utils.export_newindex_name(struct)} }},")
		self.w(f"\t\t{{ \"__index\", {utils.export_index_name(struct)} }},")
		for method in struct.findall('method'):
			method_name = method.get('export', method.get('name'))
			if not method_name.startswith("__") and not method.get('static'):
				continue
			self.w(f"\t\t{{ \"{utils.camel_case(method_name)}\", {utils.export_get_name(struct, method)} }},")
		self.w(f"\t\t{{ NULL, NULL }},")
		self.w(f"\t}}), 0);\n")
		if is_struct:
			self.w(f"\tlua_newtable(L);")
			self.w(f"\tlua_pushcfunction(L, f_{name}___call);")
			self.w(f"\tlua_setfield(L, -2, \"__call\");")
			self.w(f"\tlua_setmetatable(L, -2);\n")
		self.w(f"\treturn 1;\n}}")

	def write_property(self, property, component, path):
		cname = component.get('name')
		if property.tag == 'shorthand':
			pname, userdata = property.get('name'), property.get('userdata')
			self.w(
				f"\t/* {cname}.{pname} */ DECL({utils.hash(pname)}, {utils.hash(cname + '.' + pname)},\n"
				f"\t{cname}, \"{pname}\", {path}, kDataTypeEdges, .TypeString=\"{userdata}\"),"
			)
		else:
			name = utils.property_name(path)
			sname = utils.property_name(path)
			ptype = property.get('type')
			struct = Workspace.structs.get(ptype)
			typedata = f"kDataType{ptype[:1].upper() + ptype[1:]}"
			if struct is not None:
				export_as = struct.get('export')
				nfields = 0
				def count(p, _, c): nonlocal nfields; nfields += 1
				utils.enum_component_properties(struct, count)
				typedata = (
					f"kDataType{export_as}" if export_as
					else f"kDataTypeGroup, .TypeString=\"{ptype}\", .NumComponents={nfields}"
				)
			elif ptype in Workspace.enums or sname in Workspace.enums:
				enum = Workspace.enums.get(ptype) or Workspace.enums.get(sname)
				values = [e.get('name') for e in enum.findall('enum')]
				ptype = enum.get('name')
				typedata = f"kDataTypeEnum, .TypeString=\"{','.join(values)}\""
			elif ptype in Workspace.components:
				typedata = f"kDataTypeObject, .TypeString=\"{ptype}\""
			self.w(
				f"\t/* {cname}.{sname} */ DECL({utils.hash(sname)}, {utils.hash(cname + '.' + sname)},\n"
				f"\t{cname}, \"{sname}\", {path}, {typedata}),"
			)

	def on_component(self, root, component):
		cname = component.get('name')
		for handles in component.findall('handles'):
			event = handles.get('event')
			self.w(f"LRESULT {cname}_{event}({utils.lpobject_t}, {utils.lp(cname)}, wParam_t, {event}EventPtr);")
		self.w(f"static struct PropertyDesc const {cname}Properties[k{cname}NumProperties] = {{")

		for shorthand in component.findall("shorthand"):
			pname, physical, userdata = (
				shorthand.get('name'), shorthand.get('physical'), shorthand.get('userdata')
			)
			self.w(
				f"\t/* {cname}.{cname} */ DECL({utils.hash(pname)}, {utils.hash(cname + '.' + pname)},\n"
				f"\t{cname}, \"{pname}\", {physical}, T_EDGES, .TypeString=\"{userdata}\"),"
			)

		utils.enum_component_properties(component, self.write_property)
		self.w(f"}};")

		if bool(component.findall("property[@default]")):
			self.w(f"static struct {cname} {cname}Defaults = {{")
			for property in component.findall("property[@default]"):
				pname, ptype, pdefault = (
					property.get('name'), property.get('type'), property.get('default')
				)
				if ptype in Workspace.enums and not pdefault.lstrip('-').isdigit():
					self.w(f"\t.{pname} = k{ptype}{pdefault},")
				elif ptype in Workspace.structs:
					self.w(f"\t.{pname} = (struct {ptype}) {{ {', '.join(pdefault.split())} }},")
				elif ptype == 'bool':
					self.w(f"\t.{pname} = {pdefault.upper()},")
				elif ptype == 'fixed':
					self.w(f"\t.{pname} = \"{pdefault}\",")
				else:
					self.w(f"\t.{pname} = {pdefault},")
			self.w(f"}};")
		elif bool(component.findall("property")):
			self.w(f"static struct {cname} {cname}Defaults = {{0}};")
		else:
			self.w(f"static struct {cname} {cname}Defaults = {{}};")

		self.w(
			f"LRESULT {cname}Proc({utils.lpobject_t} object, void* cmp, "
			f"uint32_t message, wParam_t wparm, lParam_t lparm) {{"
		)
		self.w(f"\tswitch (message) {{")
		for handles in component.findall('handles'):
			hname = handles.get('event')
			self.w(f"\t\tcase {utils.hash(hname)}: // {hname}")
			self.w(f"\t\t\treturn {cname}_{hname}(object, cmp, wparm, lparm);")
		self.w(f"}}\n\treturn FALSE;\n}}")

		self.wt(_T['component_lua'].substitute(
			cname=cname,
			lpcname=utils.lpc(cname),
			lpname=utils.lp(cname),
		))

		parents = utils.component_get_parents(component)
		for p in parents:
			self.w(f"extern struct ClassDesc _{p};")
		parents_str = ", ".join([f"&_{p}" for p in parents] + ["NULL"])
		content = component.get('parent', cname)
		if component.get('name').endswith('Library'):
			content = component.get('name').replace('Library', '')
		self.wt(_T['class_desc'].substitute(
			cname=cname,
			default_name=component.get('default', cname),
			content_type=component.get('content', content),
			xmlns=component.findtext('xmlns'),
			parents_str=parents_str,
		))
