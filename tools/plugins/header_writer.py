"""C header file writer plugin."""

import os

from . import Plugin
from .utils import (
	lp, lpc, _t, _c, _e,
	hash,
	header_get_arg_type,
	header_get_method_arg,
	header_get_method_name,
	header_get_method_this,
)


class HeaderWriter(Plugin):
	"""Generates a C header (.h) file from module XML."""

	def __init__(self):
		self.file = None

	def open(self, xml, root):
		base, _ = os.path.splitext(xml)
		self.file = open(base + ".h", "w")
		self.w(f"// Generated by codegen utility")
		self.w(f"#ifndef __{root.get('name').upper()}_H__")
		self.w(f"#define __{root.get('name').upper()}_H__\n")
		self.w(f"#include <include/orca.h>\n")
		if root.find('component') is not None:
			self.w(f"#include <{base[base.index('source/'):] + '_properties.h'}>\n")

	def w(self, text):
		self.file.write(text)
		self.file.write("\n")

	def write(self, text):
		self.file.write(text)

	def close(self):
		self.w(f"#endif")
		self.file.close()

	def struct_fwd_def(self, sname):
		self.w(f"typedef struct {sname} {_t(sname)}, *{lp(sname)};")
		self.w(f"typedef struct {sname} const {_c(sname)}, *{lpc(sname)};")

	def lua_accessors(self, name):
		self.w(f"/// @brief Push {name} onto Lua stack.")
		self.w(f"ORCA_API void\nluaX_push{name}(lua_State *L, {lpc(name)} {name});")
		self.w(f"/// @brief Check {name} form Lua stack at index.")
		self.w(f"ORCA_API {lp(name)}\nluaX_check{name}(lua_State *L, int idx);\n")

	def on_external(self, _, external):
		sname = external.get('struct')
		self.struct_fwd_def(sname)

	def on_resource(self, _, resource):
		name = resource.get('type')
		self.struct_fwd_def(name)
		if resource.get('no-lua'):
			return
		self.lua_accessors(name)

	def on_include(self, _, include):
		self.w(f"#include <{include.get('file')}>")

	def on_event(self, _, event):
		ename, etype = event.get('name'), event.get('type')
		self.w(f"#define kEvent{ename} " + hash(ename))
		if etype == "void":
			self.w(f"typedef void* {ename}EventPtr;\n")
		elif etype:
			self.w(f"typedef struct {etype}* {ename}EventPtr;\n")

	def on_function(self, node, function):
		args = []
		if function.get("lua"):
			args.append("lua_State *L")
		if function.tag == "method" and function.get('static') is None:
			args.append(header_get_method_this(node, function))
		if function.findtext("summary"):
			self.w(f"/// @brief {function.findtext('summary')}")
		for arg in function.findall('arg'):
			args.append(header_get_method_arg(arg))
		args = ', '.join(args)
		returns = function.find('returns')
		ret = 'void' if returns is None else header_get_arg_type(returns)
		self.w(f"ORCA_API {ret}\n{header_get_method_name(node, function)}({args or 'void'});\n")

	def on_struct(self, _, struct):
		sname, sbrief = struct.get('name'), struct.findtext('summary')
		if sbrief:
			self.w(f"/// @brief {sbrief}")
		self.w(f"struct {sname} {{")
		for field in struct.findall('property') + struct.findall('field'):
			fname, ftype = field.get('name'), header_get_arg_type(field)
			fcomment = f" /// {field.text}" if field.text else str()
			if field.get('array'):
				self.w(f"\t{ftype} {fname}[{field.get('array')}];{fcomment}")
			else:
				self.w(f"\t{ftype} {fname};{fcomment}")
		self.w(f"}};\n")
		for method in struct.findall('method'):
			self.on_function(struct, method)

	def on_component(self, root, component):
		cname = component.get('name')
		self.w(f"typedef struct {cname} {cname}, *{cname}Ptr;")
		self.w(f"typedef struct {cname} const *{cname}CPtr;")
		self.on_struct(root, component)

	def on_interface(self, _, interface):
		for method in interface.findall('method'):
			self.on_function(interface, method)

	def on_enums(self, _, enums):
		self.w(f"typedef enum {enums.get('name')} {{")
		for enum in enums.findall('enum'):
			enum_name = f"k{enums.get('name') + enum.get('name')}"
			if enum.text:
				self.w(f"\t{enum_name}, /// {enum.text}")
			else:
				self.w(f"\t{enum_name},")
		self.w(f"}} {_e(enums.get('name'))};\n")
