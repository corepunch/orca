import sys
import os
import xml.etree.ElementTree as ET
from context import Context
from codegen_c import ParserState, w, camel_case, write_struct_fwd_def, write_push_check
from plugins import struct_plugin, component_plugin, enum_plugin, misc_plugin

def throw_no_parser(root, node, _):
	print("no such parser: ", node.tag)

def read_xml(filename, ctx, parsers):
	if not os.path.exists(filename):
		print(f"File not found: {filename}")
		return
	tree = ET.parse(filename)
	root = tree.getroot()
	parser = ParserState(filename)
	subpath = filename[filename.index("source/"):]

	if root.tag != "module":
		print("Expected 'module' tag")
		return

	tech = ET.SubElement(ctx.sidebar, 'div', {'class':'technology-title'})
	i = ET.SubElement(tech, 'span', {'class':'fa-solid fa-folder-open icon'})
	i.tail = f"{root.get('namespace')}.{root.get('name')}\n"

	h, e = parser.header, parser.export

	w(h, f"// Generated by codegen utility")
	w(h, f"#ifndef __{root.get('name').upper()}_H__")
	w(h, f"#define __{root.get('name').upper()}_H__\n")
	w(h, f"#include <include/orca.h>\n")

	w(e, f"// Generated by codegen utility")
	w(e, f"#include <include/api.h>")
	w(e, f"#include <{subpath.replace('.xml', '.h')}>")

	if root.find('component') is not None:
		w(h, f"#include <{subpath.replace('.xml', '_properties.h')}>\n")
		w(e, "#define DECL(SHORT, LONG, CLASS, NAME, FIELD, TYPE,...) { \\")
		w(e, "\t.id=&(struct ID){.Name=#CLASS\".\"NAME,.Identifier=SHORT}, \\")
		w(e, "\t.FullIdentifier=LONG, \\")
		w(e, "\t.Offset=offsetof(struct CLASS, FIELD), \\")
		w(e, "\t.DataSize=sizeof(((struct CLASS *)NULL)->FIELD), \\")
		w(e, "\t.DataType=TYPE, ##__VA_ARGS__ }")

	w(e, "")

	name, namespace = root.get('name'), root.get('namespace')

	# First pass: populate registries
	ctx.structs.update({struct.get('name'): struct for struct in root.findall(f".//struct[@name]")})
	ctx.enums.update({enum.get('name'): enum for enum in root.findall(f".//enums[@name]")})
	ctx.components.update({cmp.get('name'): cmp for cmp in root.findall(f".//component[@name]")})
	ctx.resources.update({cmp.get('type'): cmp for cmp in root.findall(f".//resource[@type]")})

	for struct in root.findall('struct')+root.findall('interface')+root.findall('component'):
		struct_name = struct.get('name')
		write_struct_fwd_def(struct_name, struct_name, parser.header)
		write_push_check(struct_name, parser.header)

	# Second pass: dispatch to plugins
	for node in root:
		parsers.get(node.tag, throw_no_parser)(root, node, parser, ctx)

	for shutdown in root.findall('shutdown'):
		fn = shutdown.get('name')
		w(e, f"static int f_{name}_gc(lua_State *L) {{\n\tvoid {fn}(void);\n\t{fn}();\n\treturn 0;\n}}")

	# write module luaopen 
	w(e, f"ORCA_API int luaopen_{namespace}_{name}(lua_State *L) {{") 
	w(e, f"\tluaL_newlib(L, ((luaL_Reg[]) {{")
	for fn in root.findall('function'):
		from codegen_c import export_get_name
		w(e, f"\t\t{{ \"{camel_case(fn.get('name'))}\", {export_get_name(root, fn)} }},")
	w(e, f"\t\t{{ NULL, NULL }}")
	w(e, f"\t}}));")
	if root.get('on-luaopen'):
		w(e, f"\tvoid {root.get('on-luaopen')}(lua_State *L);")
		w(e, f"\t{root.get('on-luaopen')}(L);")
	for struct in root.findall('struct')+root.findall('interface'):
		str_name = struct.get('name')
		w(e, f"\t// {str_name}")
		w(e, f"\tluaopen_{namespace}_{str_name}(L);") 
		w(e, f"\tlua_setfield(L, -2, \"{struct.get('export', str_name)}\");") 
	for component in root.findall('component'):
		cmp_name = component.get('name')
		w(e, f"\t// {cmp_name}")
		w(e, f"\tlua_pushclass(L, &_{cmp_name});")
		w(e, f"\tlua_setfield(L, -2, \"{cmp_name}\");")
	for shutdown in root.findall('shutdown'):
		w(e, f"\tAPI_MODULE_SHUTDOWN(L, f_{name}_gc);")
	w(e, f"\treturn 1;\n}}") 

	w(h, f"#endif")

if __name__ == "__main__":
	# Initialize global HTML structure
	g_html = ET.Element('html', attrib={'xmlns':'http://www.w3.org/2001/XMLSchema' })
	g_head = ET.SubElement(g_html, 'head')
	ET.SubElement(g_head, 'link', { "rel":"stylesheet", "href":"doc.css" })
	ET.SubElement(g_head, 'link', { "rel":"stylesheet", "href":"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" })
	ET.SubElement(g_head, 'meta', {'charset':"UTF-8"})
	g_body = ET.SubElement(g_html, 'body')
	g_wrapper = ET.SubElement(g_body, 'div', {'class': 'adjustable-sidebar-width full-width-container topic-wrapper'})
	g_sidebar = ET.SubElement(g_wrapper, 'div', {'class': 'sidebar'})
	g_content = ET.SubElement(g_wrapper, 'main', {'class': 'content'})
	g_dtd = open("schemas/orca.dtd", "w")
	g_output = "../docs/index.html"

	# Create context
	ctx = Context(
		sidebar=g_sidebar,
		content=g_content,
		dtd=g_dtd
	)

	# Register plugins
	parsers = {}
	struct_plugin.register(parsers)
	component_plugin.register(parsers)
	enum_plugin.register(parsers)
	misc_plugin.register(parsers)

	# Process all input files
	for i in range(len(sys.argv)-1):
		read_xml(sys.argv[i+1], ctx, parsers)

	# Write output
	tree = ET.ElementTree(g_html)
	tree.write(g_output, encoding="utf-8", method="html")

	with open("schemas/append.dtd") as f:
		g_dtd.write(f.read())
